//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Blocks

typedef void (^CDUnknownBlockType)(void); // return type and parameters are unknown

#pragma mark Named Structures

struct Function;

struct FunctionNode;

struct FunctionObjectData {
    unsigned long long _field1;
    unsigned int _field2;
};

struct __hash_node<FunctionObjectData, void *>;

struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>;

struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>;

struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>;

struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>;

struct __hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>;

struct __hash_node<unsigned long long, void *>;

struct __hash_table<std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, unsigned int>>> {
    struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>*>>> __bucket_list_;
    struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>*>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>>> {
        struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>*> {
            struct __hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *> *__next_;
        } __first_;
    } __p1_;
    struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::hash<unsigned long long>, true>> {
        unsigned long long __first_;
    } __p2_;
    struct __compressed_pair<float, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::equal_to<unsigned long long>, true>> {
        float __first_;
    } __p3_;
};

struct set<FunctionObjectData, std::__1::less<FunctionObjectData>, std::__1::allocator<FunctionObjectData>> {
    struct __tree<FunctionObjectData, std::__1::less<FunctionObjectData>, std::__1::allocator<FunctionObjectData>> {
        struct __tree_node<FunctionObjectData, void *> *__begin_node_;
        struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *>*>, std::__1::allocator<std::__1::__tree_node<FunctionObjectData, void *>>> {
            struct __tree_end_node<std::__1::__tree_node_base<void *>*> {
                struct __tree_node_base<void *> *__left_;
            } __first_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__1::less<FunctionObjectData>> {
            unsigned long long __first_;
        } __pair3_;
    } __tree_;
};

struct unique_ptr<std::__1::__hash_node<FunctionObjectData, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<FunctionObjectData, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<FunctionObjectData, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<FunctionObjectData, void *>*>>> {
        struct __hash_node<FunctionObjectData, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<FunctionObjectData, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<FunctionObjectData, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>*>>> {
        struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>*>>> {
        struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>*>>> {
        struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>*>>> {
        struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>*>>> {
        struct __hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<unsigned long long, unsigned int>, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unique_ptr<std::__1::__hash_node<unsigned long long, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<unsigned long long, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<unsigned long long, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<unsigned long long, void *>*>>> {
        struct __hash_node<unsigned long long, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<unsigned long long, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unordered_map<FunctionObjectData, FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, FunctionObjectData>>> {
    struct __hash_table<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, std::__1::__unordered_map_hasher<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, std::__1::hash<FunctionObjectData>, true>, std::__1::__unordered_map_equal<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, true>, std::__1::allocator<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>>> {
        struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>*>>> __bucket_list_;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>*>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *>*> {
                struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, void *> *__next_;
            } __first_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, std::__1::hash<FunctionObjectData>, true>> {
            unsigned long long __first_;
        } __p2_;
        struct __compressed_pair<float, std::__1::__unordered_map_equal<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, true>> {
            float __first_;
        } __p3_;
    } __table_;
};

struct unordered_map<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>>> {
    struct __hash_table<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, std::__1::__unordered_map_hasher<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, std::__1::hash<FunctionObjectData>, true>, std::__1::__unordered_map_equal<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, std::__1::equal_to<FunctionObjectData>, true>, std::__1::allocator<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>>> {
        struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>*>>> __bucket_list_;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>*>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *>*> {
                struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, void *> *__next_;
            } __first_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, std::__1::hash<FunctionObjectData>, true>> {
            unsigned long long __first_;
        } __p2_;
        struct __compressed_pair<float, std::__1::__unordered_map_equal<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>, std::__1::equal_to<FunctionObjectData>, true>> {
            float __first_;
        } __p3_;
    } __table_;
};

struct unordered_map<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>>> {
    struct __hash_table<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, std::__1::__unordered_map_hasher<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, std::__1::hash<FunctionObjectData>, true>, std::__1::__unordered_map_equal<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, std::__1::equal_to<FunctionObjectData>, true>, std::__1::allocator<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>>> {
        struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>*>>> __bucket_list_;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>*>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *>*> {
                struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, void *> *__next_;
            } __first_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, std::__1::hash<FunctionObjectData>, true>> {
            unsigned long long __first_;
        } __p2_;
        struct __compressed_pair<float, std::__1::__unordered_map_equal<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>, std::__1::equal_to<FunctionObjectData>, true>> {
            float __first_;
        } __p3_;
    } __table_;
};

struct unordered_map<FunctionObjectData, unsigned int, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, unsigned int>>> {
    struct __hash_table<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, std::__1::__unordered_map_hasher<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, unsigned int>, std::__1::hash<FunctionObjectData>, true>, std::__1::__unordered_map_equal<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, unsigned int>, std::__1::equal_to<FunctionObjectData>, true>, std::__1::allocator<std::__1::__hash_value_type<FunctionObjectData, unsigned int>>> {
        struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>*>>> __bucket_list_;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>*>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *>*> {
                struct __hash_node<std::__1::__hash_value_type<FunctionObjectData, unsigned int>, void *> *__next_;
            } __first_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, unsigned int>, std::__1::hash<FunctionObjectData>, true>> {
            unsigned long long __first_;
        } __p2_;
        struct __compressed_pair<float, std::__1::__unordered_map_equal<FunctionObjectData, std::__1::__hash_value_type<FunctionObjectData, unsigned int>, std::__1::equal_to<FunctionObjectData>, true>> {
            float __first_;
        } __p3_;
    } __table_;
};

struct unordered_map<unsigned long long, unsigned int, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, unsigned int>>> {
    struct __hash_table<std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, unsigned int>>> __table_;
};

struct unordered_multimap<unsigned long long, unsigned int, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, unsigned int>>> {
    struct __hash_table<std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::__unordered_map_hasher<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::hash<unsigned long long>, true>, std::__1::__unordered_map_equal<unsigned long long, std::__1::__hash_value_type<unsigned long long, unsigned int>, std::__1::equal_to<unsigned long long>, true>, std::__1::allocator<std::__1::__hash_value_type<unsigned long long, unsigned int>>> __table_;
};

struct unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>> {
    struct __hash_table<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>> {
        struct unique_ptr<std::__1::__hash_node<FunctionObjectData, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<FunctionObjectData, void *>*>>> __bucket_list_;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<FunctionObjectData, void *>*>, std::__1::allocator<std::__1::__hash_node<FunctionObjectData, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<FunctionObjectData, void *>*> {
                struct __hash_node<FunctionObjectData, void *> *__next_;
            } __first_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__1::hash<FunctionObjectData>> {
            unsigned long long __first_;
        } __p2_;
        struct __compressed_pair<float, std::__1::equal_to<FunctionObjectData>> {
            float __first_;
        } __p3_;
    } __table_;
};

struct unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long>> {
    struct __hash_table<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long>> {
        struct unique_ptr<std::__1::__hash_node<unsigned long long, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<unsigned long long, void *>*>>> __bucket_list_;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<unsigned long long, void *>*>, std::__1::allocator<std::__1::__hash_node<unsigned long long, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<unsigned long long, void *>*> {
                struct __hash_node<unsigned long long, void *> *__next_;
            } __first_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__1::hash<unsigned long long>> {
            unsigned long long __first_;
        } __p2_;
        struct __compressed_pair<float, std::__1::equal_to<unsigned long long>> {
            float __first_;
        } __p3_;
    } __table_;
};

struct vector<FunctionNode, std::__1::allocator<FunctionNode>> {
    struct FunctionNode *__begin_;
    struct FunctionNode *__end_;
    struct __compressed_pair<FunctionNode *, std::__1::allocator<FunctionNode>> {
        struct FunctionNode *__first_;
    } __end_cap_;
};

struct vector<GPUTools::FD::Function, std::__1::allocator<GPUTools::FD::Function>> {
    struct Function *__begin_;
    struct Function *__end_;
    struct __compressed_pair<GPUTools::FD::Function *, std::__1::allocator<GPUTools::FD::Function>> {
        struct Function *__first_;
    } __end_cap_;
};

struct vector<unsigned int, std::__1::allocator<unsigned int>> {
    unsigned int *__begin_;
    unsigned int *__end_;
    struct __compressed_pair<unsigned int *, std::__1::allocator<unsigned int>> {
        unsigned int *__first_;
    } __end_cap_;
};

#pragma mark -

//
// File: /Applications/Xcode-7GM.app/Contents/SharedFrameworks/MTLToolsServices.framework/Versions/A/MTLToolsServices
// UUID: CBC837CA-2ECE-3C6C-8AD6-AFF1B3B10F38
//
//                           Arch: x86_64
//                Current version: 1.0.0
//          Compatibility version: 1.0.0
//                 Source version: 18058.0.0.0.0
//       Minimum Mac OS X version: 10.10.0
//                    SDK version: 10.11.0
//
// Objective-C Garbage Collection: Unsupported
//

@protocol DYBuffer <DYResource, DYCacheableResource>
@property(readonly, nonatomic) NSData *data;
@end

@protocol DYCacheableResource <NSObject>
@property(readonly, nonatomic) unsigned long long cachingCost;
@end

@protocol DYFrameBuffer <DYResource>
@property(readonly, nonatomic) NSDictionary *attachmentsDict;
- (id)initWithProperties:(NSDictionary *)arg1;
@end

@protocol DYResource <NSObject, NSCoding>
+ (NSString *)keyForResourceWithID:(unsigned long long)arg1 type:(unsigned int)arg2 containerID:(unsigned long long)arg3;
@property(readonly, nonatomic) BOOL isStatic;
@property(readonly, nonatomic) NSMutableDictionary *properties;
@property(readonly, copy, nonatomic) NSString *label;
@property(readonly, nonatomic) unsigned long long objectID;
@property(readonly, nonatomic) unsigned long long containerID;
@property(readonly, nonatomic) unsigned int resourceType;
- (id)initUpdateWithType:(unsigned int)arg1 objectID:(unsigned long long)arg2 containerID:(unsigned long long)arg3 changes:(NSDictionary *)arg4;

@optional
- (id)createFullObjectWithFunctionStream:(DYFunctionStream *)arg1 dataResolver:(NSData * (^)(char *))arg2;
- (NSDictionary *)streamDictAtFunctionIndex:(unsigned int)arg1;
- (NSString *)keyWithSharegroupID:(unsigned long long)arg1;
@end

@protocol DYTexture <DYResource, DYCacheableResource>
@property(readonly, nonatomic) BOOL isFlipped;
@property(readonly, nonatomic) BOOL isCubemap;
@property(readonly, nonatomic) id <DYTextureImage> firstValidTextureImage;
@property(readonly, nonatomic) unsigned int mipmapLevelsUsedMask;
@property(readonly, nonatomic) int maxMipmapLevel;
@property(readonly, nonatomic) int baseMipmapLevel;
- (NSString *)cubemapLabelForFaceIndex:(int)arg1;
- (id <DYTextureImage>)textureImageForMipmapLevel:(int)arg1 layer:(int)arg2;
- (unsigned int)layerCountForMipmapLevel:(unsigned int)arg1;
@end

@protocol DYTextureImage <NSObject, DYCacheableResource>
+ (NSString *)textureImageKeyForLevel:(unsigned int)arg1 layer:(unsigned int)arg2;
@property(readonly, nonatomic) unsigned long long offset;
@property(readonly, nonatomic) NSData *data;
@property(readonly, nonatomic) int layerIndex;
@property(readonly, nonatomic) int mipmapLevel;
@property(readonly, nonatomic) unsigned int numSamples;
@property(readonly, nonatomic) unsigned long long depth;
@property(readonly, nonatomic) unsigned long long height;
@property(readonly, nonatomic) unsigned long long width;
@property(readonly, nonatomic) unsigned int genericFormat;
- (NSData *)uncompressedData;
@end

@protocol DYTextureImageBackingStore <NSObject, DYCacheableResource>
@property(retain, nonatomic) NSData *uncompressedData;
@property(retain, nonatomic) NSData *data;
@end

@protocol NSCoding
- (id)initWithCoder:(NSCoder *)arg1;
- (void)encodeWithCoder:(NSCoder *)arg1;
@end

@protocol NSObject
@property(readonly, copy) NSString *description;
@property(readonly) Class superclass;
@property(readonly) unsigned long long hash;
- (struct _NSZone *)zone;
- (unsigned long long)retainCount;
- (id)autorelease;
- (oneway void)release;
- (id)retain;
- (BOOL)respondsToSelector:(SEL)arg1;
- (BOOL)conformsToProtocol:(Protocol *)arg1;
- (BOOL)isMemberOfClass:(Class)arg1;
- (BOOL)isKindOfClass:(Class)arg1;
- (BOOL)isProxy;
- (id)performSelector:(SEL)arg1 withObject:(id)arg2 withObject:(id)arg3;
- (id)performSelector:(SEL)arg1 withObject:(id)arg2;
- (id)performSelector:(SEL)arg1;
- (id)self;
- (Class)class;
- (BOOL)isEqual:(id)arg1;

@optional
@property(readonly, copy) NSString *debugDescription;
@end

@interface DYMTLResourceObject : NSObject <DYResource>
{
    BOOL _isStatic;
    unsigned int _resourceType;
    unsigned long long _containerID;
    unsigned long long _objectID;
    NSString *_label;
    NSMutableDictionary *_properties;
}

+ (id)keyForResourceWithID:(unsigned long long)arg1 type:(unsigned int)arg2 containerID:(unsigned long long)arg3;
@property(readonly, nonatomic) BOOL isStatic; // @synthesize isStatic=_isStatic;
@property(readonly, nonatomic) NSMutableDictionary *properties; // @synthesize properties=_properties;
@property(readonly, copy, nonatomic) NSString *label; // @synthesize label=_label;
@property(readonly, nonatomic) unsigned long long objectID; // @synthesize objectID=_objectID;
@property(readonly, nonatomic) unsigned long long containerID; // @synthesize containerID=_containerID;
@property(readonly, nonatomic) unsigned int resourceType; // @synthesize resourceType=_resourceType;
- (void).cxx_destruct;
- (id)streamDictAtFunctionIndex:(unsigned int)arg1;
- (id)createFullObjectWithFunctionStream:(id)arg1 dataResolver:(CDUnknownBlockType)arg2;
- (void)encodeWithCoder:(id)arg1;
- (id)initWithCoder:(id)arg1;
- (id)initUpdateWithType:(unsigned int)arg1 objectID:(unsigned long long)arg2 containerID:(unsigned long long)arg3 changes:(id)arg4;
- (id)initWithResourceObject:(id)arg1 isStatic:(BOOL)arg2;
- (id)initWithType:(unsigned int)arg1 properties:(id)arg2;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

@interface DYMTLBuffer : DYMTLResourceObject <DYBuffer>
{
    BOOL _zeroFill;
    BOOL _isBytesOnly;
    NSData *_data;
    unsigned long long _length;
    unsigned long long _cpuCacheMode;
    unsigned long long _resourceOptions;
    unsigned long long _purgeableState;
}

@property(readonly, nonatomic) BOOL isBytesOnly; // @synthesize isBytesOnly=_isBytesOnly;
@property(readonly, nonatomic) unsigned long long purgeableState; // @synthesize purgeableState=_purgeableState;
@property(readonly, nonatomic) unsigned long long resourceOptions; // @synthesize resourceOptions=_resourceOptions;
@property(readonly, nonatomic) unsigned long long cpuCacheMode; // @synthesize cpuCacheMode=_cpuCacheMode;
@property(readonly, nonatomic) BOOL zeroFill; // @synthesize zeroFill=_zeroFill;
@property(readonly, nonatomic) unsigned long long length; // @synthesize length=_length;
@property(readonly, nonatomic) NSData *data; // @synthesize data=_data;
- (void).cxx_destruct;
@property(readonly, nonatomic) unsigned long long cachingCost;
- (id)initWithResourceObject:(id)arg1 functionStream:(id)arg2 dataResolver:(CDUnknownBlockType)arg3;
- (id)_initWithBuffer:(id)arg1 isStatic:(BOOL)arg2;
- (id)initWithProperties:(id)arg1;

// Remaining properties
@property(readonly, nonatomic) unsigned long long containerID;
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly, nonatomic) BOOL isStatic;
@property(readonly, copy, nonatomic) NSString *label;
@property(readonly, nonatomic) unsigned long long objectID;
@property(readonly, nonatomic) NSMutableDictionary *properties;
@property(readonly, nonatomic) unsigned int resourceType;
@property(readonly) Class superclass;

@end

@interface DYMTLCaptureSession : DYCaptureSession
{
    unsigned long long _captureCommandQueueAddress;
}

@property(nonatomic) unsigned long long captureCommandQueueAddress; // @synthesize captureCommandQueueAddress=_captureCommandQueueAddress;
- (void)_saveAPISpecificData:(id)arg1;
- (id)_allowedSessionInfoBaseClasses;
- (void)_setupFinalConfigurationDictionary:(id)arg1;
- (void)_postProcessArchive;

@end

__attribute__((visibility("hidden")))
@interface DYMTLCaptureStreamSorter : NSObject
{
    DYCaptureArchive *_archive;
    struct vector<unsigned int, std::__1::allocator<unsigned int>> _numFunctionsForFiles;
    struct vector<GPUTools::FD::Function, std::__1::allocator<GPUTools::FD::Function>> _originalFunctionStream;
    struct vector<GPUTools::FD::Function, std::__1::allocator<GPUTools::FD::Function>> _modifiedFunctionStream;
    struct vector<GPUTools::FD::Function, std::__1::allocator<GPUTools::FD::Function>> _postProcessedModifiedFunctionStream;
    struct vector<unsigned int, std::__1::allocator<unsigned int>> _functionSubmissionOrder;
    struct vector<FunctionNode, std::__1::allocator<FunctionNode>> _functionNodes;
    struct unordered_map<FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, std::__1::tuple<unsigned int, unsigned int>>>> _commandBufferOrder;
    struct unordered_map<FunctionObjectData, unsigned int, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, unsigned int>>> _constructionIndexMap;
    struct unordered_map<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>>> _commandBufferToResourceContainerMap;
    struct unordered_map<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>>> _resourceContainerMap;
    struct unordered_map<FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, std::__1::unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>>>>> _commandBufferToResourceMap;
    struct unordered_set<FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<FunctionObjectData>> _commandEncoderSet;
    struct unordered_map<FunctionObjectData, FunctionObjectData, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, FunctionObjectData>>> _childToParentMap;
    struct unordered_map<FunctionObjectData, unsigned int, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, unsigned int>>> _precedingRelatives;
    struct unordered_map<FunctionObjectData, unsigned int, std::__1::hash<FunctionObjectData>, std::__1::equal_to<FunctionObjectData>, std::__1::allocator<std::__1::pair<const FunctionObjectData, unsigned int>>> _postOrderRelatives;
    struct set<FunctionObjectData, std::__1::less<FunctionObjectData>, std::__1::allocator<FunctionObjectData>> _auxiliaryResourceSet;
    struct unordered_multimap<unsigned long long, unsigned int, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, unsigned int>>> _resourceToCommandBufferMap;
    struct unordered_map<unsigned long long, unsigned int, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<std::__1::pair<const unsigned long long, unsigned int>>> _receiverCreationIndex;
    BOOL _hasParallelRenderCommandEncoder;
    unsigned long long _nextDrawableId;
    unsigned long long _usedDrawableId;
}

@property(nonatomic) unsigned long long usedDrawableId; // @synthesize usedDrawableId=_usedDrawableId;
@property(nonatomic) unsigned long long nextDrawableId; // @synthesize nextDrawableId=_nextDrawableId;
@property(nonatomic) BOOL hasParallelRenderCommandEncoder; // @synthesize hasParallelRenderCommandEncoder=_hasParallelRenderCommandEncoder;
@property(retain, nonatomic) DYCaptureArchive *archive; // @synthesize archive=_archive;
- (id).cxx_construct;
- (void).cxx_destruct;
- (BOOL)_shouldExecuteFunctionLast:(unsigned int)arg1;
- (BOOL)_shouldRunPostCommandBufferCommit:(unsigned int)arg1;
- (BOOL)_shouldIgnoreFunction:(unsigned int)arg1;
- (void)_postProcessParallelRenderCommandEncoder;
- (unsigned int)_flattenParallelRenderCommandEncodingAtIndex:(unsigned int)arg1;
- (void)_sortFunctionStreamCommands:(unsigned int)arg1;
- (unsigned long long)_getCAMTLLayerId;
- (unsigned int)_traverseHeirarchyAndDetermineOrder;
- (void)_buildFunctionNodeHierarchy;
- (void)_handleNonCommandBufferDescendentsForFunction:(unsigned int)arg1 withActiveCommandBufferIndex:(unsigned int)arg2 andLastCommandBufferCommitted:(_Bool)arg3 andLastestCommandBufferUsedOrder:(unsigned int)arg4;
- (BOOL)_handleCommandBufferDescendentsForFunction:(unsigned int)arg1;
- (void)_createCommandBufferNodes;
- (void)_createFamilyList;
- (void)_findRelativesAndCommandBufferOrdering;
- (struct FunctionObjectData)_findLatestCreatedObject:(unsigned long long)arg1;
- (unsigned int)_creationIndexForObject:(unsigned long long)arg1;
- (void)_findCommandBufferResourceContainerRelatives;
- (void)_determineCommandBufferSubmissionReorder;
- (void)_writeModifiedFunctionStream;
- (void)_writeUnmodifiedFunctionStream;
- (void)_readOriginalFunctionStream;
- (void)_dumpDebugData;
- (BOOL)processCaptureStream;
- (id)initWithCaptureArchive:(id)arg1;

@end

@interface DYMTLCapturingLoopingDeltaGenerator : DYCaptureVisitor
{
    struct unordered_set<unsigned long long, std::__1::hash<unsigned long long>, std::__1::equal_to<unsigned long long>, std::__1::allocator<unsigned long long>> _unrestoredTextures;
}

+ (id)_createEmptyFunctionBufferStream;
- (id).cxx_construct;
- (void).cxx_destruct;
- (void)_determineUnrestoredTexturesWithArchive:(id)arg1;
- (void)visitCaptureArchive:(id)arg1;

@end

@interface DYMTLComputePipelineState : DYMTLResourceObject
{
    unsigned long long _function;
}

@property(readonly, nonatomic) unsigned long long function; // @synthesize function=_function;
- (id)initWithProperties:(id)arg1;
- (id)initWithResourceObject:(id)arg1 functionStream:(id)arg2 dataResolver:(CDUnknownBlockType)arg3;

@end

@interface DYMTLFramebuffer : DYMTLResourceObject <DYFrameBuffer>
{
    unsigned long long _visibilityResultBuffer;
    NSDictionary *_attachmentsDict;
}

@property(readonly, nonatomic) NSDictionary *attachmentsDict; // @synthesize attachmentsDict=_attachmentsDict;
@property(readonly, nonatomic) unsigned long long visibilityResultBuffer; // @synthesize visibilityResultBuffer=_visibilityResultBuffer;
- (void).cxx_destruct;
- (id)initWithProperties:(id)arg1;

// Remaining properties
@property(readonly, nonatomic) unsigned long long containerID;
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly, nonatomic) BOOL isStatic;
@property(readonly, copy, nonatomic) NSString *label;
@property(readonly, nonatomic) unsigned long long objectID;
@property(readonly, nonatomic) NSMutableDictionary *properties;
@property(readonly, nonatomic) unsigned int resourceType;
@property(readonly) Class superclass;

@end

@interface DYMTLFramebufferAttachment : NSObject
{
    unsigned int _attachmentIndex;
    unsigned long long _textureID;
    unsigned long long _level;
    unsigned long long _slice;
    unsigned long long _depthPlane;
    unsigned long long _resolveTextureID;
    unsigned long long _resolveLevel;
    unsigned long long _resolveSlice;
    unsigned long long _resolveDepthPlane;
    unsigned long long _loadAction;
    unsigned long long _storeAction;
}

@property(readonly, nonatomic) unsigned long long storeAction; // @synthesize storeAction=_storeAction;
@property(readonly, nonatomic) unsigned long long loadAction; // @synthesize loadAction=_loadAction;
@property(readonly, nonatomic) unsigned long long resolveDepthPlane; // @synthesize resolveDepthPlane=_resolveDepthPlane;
@property(readonly, nonatomic) unsigned long long resolveSlice; // @synthesize resolveSlice=_resolveSlice;
@property(readonly, nonatomic) unsigned long long resolveLevel; // @synthesize resolveLevel=_resolveLevel;
@property(readonly, nonatomic) unsigned long long resolveTextureID; // @synthesize resolveTextureID=_resolveTextureID;
@property(readonly, nonatomic) unsigned long long depthPlane; // @synthesize depthPlane=_depthPlane;
@property(readonly, nonatomic) unsigned long long slice; // @synthesize slice=_slice;
@property(readonly, nonatomic) unsigned long long level; // @synthesize level=_level;
@property(readonly, nonatomic) unsigned long long textureID; // @synthesize textureID=_textureID;
@property(readonly, nonatomic) unsigned int attachmentIndex; // @synthesize attachmentIndex=_attachmentIndex;
- (id)initWithTextureID:(unsigned long long)arg1 attachmentIndex:(unsigned int)arg2 level:(unsigned long long)arg3 slice:(unsigned long long)arg4 depthPlane:(unsigned long long)arg5 resolveTextureID:(unsigned long long)arg6 resolveLevel:(unsigned long long)arg7 resolveSlice:(unsigned long long)arg8 resolveDepthPlane:(unsigned long long)arg9 loadAction:(unsigned long long)arg10 storeAction:(unsigned long long)arg11;
- (id)init;

@end

@interface DYMTLFunction : DYMTLResourceObject
{
    NSString *_name;
    unsigned long long _type;
    unsigned long long _libraryID;
}

@property(readonly, nonatomic) unsigned long long libraryID; // @synthesize libraryID=_libraryID;
@property(nonatomic) unsigned long long type; // @synthesize type=_type;
@property(readonly, copy, nonatomic) NSString *name; // @synthesize name=_name;
- (void).cxx_destruct;
- (id)initWithProperties:(id)arg1;
- (id)initWithResourceObject:(id)arg1 functionStream:(id)arg2 dataResolver:(CDUnknownBlockType)arg3;

@end

@interface DYMTLGuestAppSession : DYGuestAppSession
{
    unsigned int _deviceWrapper;
    unsigned int _validationMode;
}

@property(nonatomic) unsigned int validationMode; // @synthesize validationMode=_validationMode;
@property(nonatomic) unsigned int deviceWrapper; // @synthesize deviceWrapper=_deviceWrapper;
- (id)newCaptureSessionWithArchive:(id)arg1;
- (id)queryForGraphicsAPIUsage;
- (id)launch;
- (void)_handleTransportMessage:(id)arg1;
- (id)initWithGuestApp:(id)arg1 device:(id)arg2 deferLaunch:(BOOL)arg3;

@end

@interface DYMTLLibrary : DYMTLResourceObject
{
    BOOL _onlineCompiled;
    NSSet *_sourceURLs;
}

@property(readonly, nonatomic, getter=isOnlineCompiled) BOOL onlineCompiled; // @synthesize onlineCompiled=_onlineCompiled;
@property(readonly, nonatomic) NSSet *sourceURLs; // @synthesize sourceURLs=_sourceURLs;
- (void).cxx_destruct;
- (id)initWithProperties:(id)arg1;
- (id)initWithResourceObject:(id)arg1 functionStream:(id)arg2 dataResolver:(CDUnknownBlockType)arg3;

@end

@interface DYMTLPixelFormatConverter : NSObject
{
}

+ (unsigned int)formatConvertToGeneric:(unsigned long long)arg1;
+ (unsigned long long)formatConvertToMTL:(unsigned int)arg1;
+ (void)_initDictionaries;
+ (void)initialize;

@end

@interface DYMTLRenderPipelineState : DYMTLResourceObject
{
    unsigned long long _vertexFunction;
    unsigned long long _fragmentFunction;
}

@property(readonly, nonatomic) unsigned long long fragmentFunction; // @synthesize fragmentFunction=_fragmentFunction;
@property(readonly, nonatomic) unsigned long long vertexFunction; // @synthesize vertexFunction=_vertexFunction;
- (id)initWithProperties:(id)arg1;
- (id)initWithResourceObject:(id)arg1 functionStream:(id)arg2 dataResolver:(CDUnknownBlockType)arg3;

@end

@interface DYMTLTexture : DYMTLResourceObject <DYTexture>
{
    NSDictionary *_images;
    int _layerCount;
    BOOL _zeroFill;
    int _maxMipmapLevel;
    unsigned long long _type;
    unsigned long long _pixelFormat;
    unsigned long long _arrayLength;
    unsigned long long _rotation;
    unsigned long long _cpuCacheMode;
    unsigned long long _purgeableState;
    unsigned long long _storageMode;
    unsigned long long _sampleCount;
}

@property(readonly, nonatomic) unsigned long long sampleCount; // @synthesize sampleCount=_sampleCount;
@property(readonly, nonatomic) unsigned long long storageMode; // @synthesize storageMode=_storageMode;
@property(readonly, nonatomic) unsigned long long purgeableState; // @synthesize purgeableState=_purgeableState;
@property(readonly, nonatomic) unsigned long long cpuCacheMode; // @synthesize cpuCacheMode=_cpuCacheMode;
@property(readonly, nonatomic) BOOL zeroFill; // @synthesize zeroFill=_zeroFill;
@property(readonly, nonatomic) unsigned long long rotation; // @synthesize rotation=_rotation;
@property(readonly, nonatomic) unsigned long long arrayLength; // @synthesize arrayLength=_arrayLength;
@property(readonly, nonatomic) unsigned long long pixelFormat; // @synthesize pixelFormat=_pixelFormat;
@property(readonly, nonatomic) unsigned long long type; // @synthesize type=_type;
@property(readonly, nonatomic) int maxMipmapLevel; // @synthesize maxMipmapLevel=_maxMipmapLevel;
- (void).cxx_destruct;
@property(readonly, nonatomic) unsigned int mipmapLevelsUsedMask; // @dynamic mipmapLevelsUsedMask;
- (unsigned int)layerCountForMipmapLevel:(unsigned int)arg1;
@property(readonly, nonatomic) int baseMipmapLevel;
@property(readonly, nonatomic) BOOL isFlipped;
- (id)cubemapLabelForFaceIndex:(int)arg1;
@property(readonly, nonatomic) BOOL isCubemap; // @dynamic isCubemap;
- (id)textureImageForMipmapLevel:(int)arg1 layer:(int)arg2;
@property(readonly, nonatomic) id <DYTextureImage> firstValidTextureImage; // @dynamic firstValidTextureImage;
@property(readonly, nonatomic) unsigned long long cachingCost;
- (id)initWithResourceObject:(id)arg1 functionStream:(id)arg2 dataResolver:(CDUnknownBlockType)arg3;
- (id)_initWithTexture:(id)arg1 isStatic:(BOOL)arg2;
- (id)initWithProperties:(id)arg1;

// Remaining properties
@property(readonly, nonatomic) unsigned long long containerID;
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly, nonatomic) BOOL isStatic;
@property(readonly, copy, nonatomic) NSString *label;
@property(readonly, nonatomic) unsigned long long objectID;
@property(readonly, nonatomic) NSMutableDictionary *properties;
@property(readonly, nonatomic) unsigned int resourceType;
@property(readonly) Class superclass;

@end

@interface DYMTLTextureImage : NSObject <DYTextureImage>
{
    DYMTLTextureImageBackingStore *_backingStore;
    NSData *_data;
    NSData *_uncompressedData;
    unsigned int _genericFormat;
    int _mipmapLevel;
    int _layerIndex;
    unsigned int _numSamples;
    unsigned long long _width;
    unsigned long long _height;
    unsigned long long _depth;
    unsigned long long _offset;
    unsigned long long _rowBytes;
    unsigned long long _imageBytes;
}

+ (id)_imagesFor3DTextureWithProperties:(id)arg1;
+ (id)imagesFromProperties:(id)arg1;
+ (id)textureImageKeyForLevel:(unsigned int)arg1 layer:(unsigned int)arg2;
@property(readonly, nonatomic) unsigned long long imageBytes; // @synthesize imageBytes=_imageBytes;
@property(readonly, nonatomic) unsigned long long rowBytes; // @synthesize rowBytes=_rowBytes;
@property(readonly, nonatomic) unsigned long long offset; // @synthesize offset=_offset;
@property(readonly, nonatomic) unsigned int numSamples; // @synthesize numSamples=_numSamples;
@property(readonly, nonatomic) int layerIndex; // @synthesize layerIndex=_layerIndex;
@property(readonly, nonatomic) int mipmapLevel; // @synthesize mipmapLevel=_mipmapLevel;
@property(readonly, nonatomic) unsigned long long depth; // @synthesize depth=_depth;
@property(readonly, nonatomic) unsigned long long height; // @synthesize height=_height;
@property(readonly, nonatomic) unsigned long long width; // @synthesize width=_width;
@property(readonly, nonatomic) unsigned int genericFormat; // @synthesize genericFormat=_genericFormat;
- (void).cxx_destruct;
@property(readonly, nonatomic) unsigned long long cachingCost;
- (id)uncompressedData;
@property(readonly, nonatomic) NSData *data; // @dynamic data;
- (id)_initWithProperties:(id)arg1;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

@interface DYMTLTextureImageBackingStore : NSObject <DYTextureImageBackingStore>
{
    int lock;
    NSData *_data;
    NSData *_uncompressedData;
}

@property(retain, nonatomic) NSData *uncompressedData; // @synthesize uncompressedData=_uncompressedData;
@property(retain, nonatomic) NSData *data; // @synthesize data=_data;
- (void).cxx_destruct;
@property(readonly, nonatomic) unsigned long long cachingCost;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end


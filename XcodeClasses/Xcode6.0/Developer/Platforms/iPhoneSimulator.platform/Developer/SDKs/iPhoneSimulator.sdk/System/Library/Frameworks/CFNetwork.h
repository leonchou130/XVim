//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Blocks

typedef void (^CDUnknownBlockType)(void); // return type and parameters are unknown

#pragma mark Named Structures

struct BaseAwaitingTube;

struct BaseTubeManager;

struct CFURLProtocolClient {
    long long version;
    void *client;
    CDUnknownFunctionPointerType retain;
    CDUnknownFunctionPointerType release;
    CDUnknownFunctionPointerType copyDescription;
    CDUnknownFunctionPointerType wasRedirected;
    CDUnknownFunctionPointerType cacheResponseIsValid;
    CDUnknownFunctionPointerType didReceiveResponse;
    CDUnknownFunctionPointerType didLoadData;
    CDUnknownFunctionPointerType didFinishLoading;
    CDUnknownFunctionPointerType didFail;
    CDUnknownFunctionPointerType didReceiveAuthenticationChallenge;
};

struct CFURLProtocolImplementation {
    long long _field1;
    void *_field2;
    CDUnknownFunctionPointerType _field3;
    CDUnknownFunctionPointerType _field4;
    CDUnknownFunctionPointerType _field5;
    CDUnknownFunctionPointerType _field6;
    CDUnknownFunctionPointerType _field7;
    CDUnknownFunctionPointerType _field8;
    CDUnknownFunctionPointerType _field9;
};

struct CFURLProtocolInstanceCallbacks {
    long long _field1;
    CDUnknownFunctionPointerType _field2;
    CDUnknownFunctionPointerType _field3;
    CDUnknownFunctionPointerType _field4;
    CDUnknownFunctionPointerType _field5;
    CDUnknownFunctionPointerType _field6;
    CDUnknownFunctionPointerType _field7;
    CDUnknownFunctionPointerType _field8;
    CDUnknownFunctionPointerType _field9;
    CDUnknownFunctionPointerType _field10;
    CDUnknownFunctionPointerType _field11;
    CDUnknownFunctionPointerType _field12;
    CDUnknownFunctionPointerType _field13;
    void *_field14;
};

struct ConfigFlags {
    unsigned int :1;
    unsigned int :1;
    unsigned int :1;
    unsigned int :1;
    unsigned int :1;
    unsigned int :1;
    unsigned int :1;
};

struct CoreLockable;

struct CoreSchedulingSet {
    CDUnknownFunctionPointerType *_field1;
    struct __CFAllocator *_field2;
    int _field3;
    CDUnknownFunctionPointerType *_field4;
    struct _opaque_pthread_t *_field5;
    int _field6;
    struct __CFSet *_field7;
    id _field8;
    id _field9;
    struct __CFRunLoop *_field10;
    struct __CFString *_field11;
    int _field12;
};

struct HTTPBodyData;

struct HTTPConnectionCacheKey {
    CDUnknownFunctionPointerType *_field1;
    struct __CFAllocator *_field2;
    int _field3;
    unsigned long long _field4;
    struct __CFString *_field5;
    int _field6;
    int _field7;
    struct __CFDictionary *_field8;
    unsigned long long _field9;
    struct __CFDictionary *_field10;
    struct NetworkProxy *_field11;
    struct __CFString *_field12;
    int _field13;
    int _field14;
};

struct HTTPConnectionCacheLimits {
    int _field1;
    int _field2;
    int _field3;
    int _field4;
    int _field5;
    int _field6;
    int _field7;
    int _field8;
    int _field9;
    int _field10;
};

struct HTTPHeaderDict;

struct HTTPMethodMixedValue {
    CDUnknownFunctionPointerType *_field1;
    struct __CFString *_field2;
};

struct HTTPParser;

struct HTTPRequestMessage {
    CDUnknownFunctionPointerType *_field1;
    CDUnknownFunctionPointerType *_field2;
    CDUnknownFunctionPointerType *_field3;
    unsigned char _field4;
    struct HTTPVersionMixedValue _field5;
    struct HTTPBodyData *_field6;
    int _field7;
    long long _field8;
    struct _CFHTTPAuthentication *_field9;
    struct _CFHTTPAuthentication *_field10;
    struct HTTPParser *_field11;
    struct HTTPHeaderDict *_field12;
    struct HTTPHeaderDict *_field13;
    CDUnknownFunctionPointerType *_field14;
    struct __CFAllocator *_field15;
    struct HTTPMethodMixedValue _field16;
    char *_field17;
    struct __CFURL *_field18;
    char *_field19;
};

struct HTTPVersionMixedValue {
    CDUnknownFunctionPointerType *_field1;
    struct __CFString *_field2;
};

struct InterfaceRequiredForLoader;

struct InternalInit {
    id _field1;
    id _field2;
    id _field3;
    id _field4;
    _Bool _field5;
    long long _field6;
};

struct InternalProtocolImplementation {
    long long _field1;
    void *_field2;
    CDUnknownFunctionPointerType _field3;
    CDUnknownFunctionPointerType _field4;
    CDUnknownFunctionPointerType _field5;
    CDUnknownFunctionPointerType _field6;
    CDUnknownFunctionPointerType _field7;
    CDUnknownFunctionPointerType _field8;
    CDUnknownFunctionPointerType _field9;
};

struct MetaConnectionCacheClient {
    CDUnknownFunctionPointerType *_field1;
};

struct MetaConnectionOptions {
    int _field1;
    float _field2;
    unsigned long long _field3;
    unsigned char _field4;
    unsigned char _field5;
    unsigned char _field6;
};

struct NSCFURLProtocolClient {
    CDUnknownFunctionPointerType *_field1;
    CDUnknownFunctionPointerType *_field2;
    id _field3;
    id _field4;
};

struct NetworkProxy;

struct PerformanceTiming;

struct RedirectionRecorder;

struct RetainableTypedDict<const CoreSchedulingSet *, TubeManager *>;

struct SessionConnectionLoadable {
    CDUnknownFunctionPointerType *_field1;
    long long _field2;
    long long _field3;
    long long _field4;
    long long _field5;
    CDUnknownFunctionPointerType *_field6;
    CDUnknownFunctionPointerType *_field7;
    id _field8;
};

struct SocketStreamObject;

struct Tube {
    CDUnknownFunctionPointerType *_field1;
    struct __CFAllocator *_field2;
    int _field3;
    CDUnknownFunctionPointerType *_field4;
    CDUnknownFunctionPointerType *_field5;
    struct HTTPConnectionCacheKey *_field6;
    struct BaseTubeManager *_field7;
    struct CoreSchedulingSet *_field8;
    struct BaseAwaitingTube *_field9;
    struct SocketStreamObject *_field10;
    int _field11;
    _Bool _field12;
    struct {
        _Bool _field1;
        unsigned long long _field2;
    } _field13;
    int _field14;
    _Bool _field15;
    _Bool _field16;
    _Bool _field17;
    struct __CFArray *_field18;
    struct __SecTrust *_field19;
    struct NetworkProxy *_field20;
    CDUnknownBlockType _field21;
    CDUnknownBlockType _field22;
    struct __CFReadStream *_field23;
    struct __CFWriteStream *_field24;
};

struct URLConnectionLoader {
    CDUnknownFunctionPointerType *_field1;
    struct __CFAllocator *_field2;
    CDUnknownFunctionPointerType *_field3;
    unsigned char _field4;
    unsigned char _field5;
    struct InterfaceRequiredForLoader *_field6;
    id _field7;
    CDUnknownFunctionPointerType *_field8;
    CDUnknownFunctionPointerType *_field9;
    struct PerformanceTiming *_field10;
    id _field11;
    long long _field12;
    struct RedirectionRecorder *_field13;
    unsigned char _field14;
    unsigned char _field15;
    unsigned char _field16;
    id _field17;
    unsigned char _field18;
    double _field19;
    struct URLProtocol *_field20;
    id _field21;
    unsigned char _field22;
    struct CoreSchedulingSet *_field23;
    double _field24;
    double _field25;
    unsigned long long _field26;
    struct ConfigFlags _field27;
    unsigned char _field28;
    unsigned char _field29;
    unsigned char _field30;
    unsigned char _field31;
};

struct URLProtocol {
    CDUnknownFunctionPointerType *_field1;
    CDUnknownFunctionPointerType *_field2;
    struct CoreSchedulingSet *_field3;
    double _field4;
    unsigned char _field5;
    unsigned char _field6;
    unsigned char _field7;
    unsigned char _field8;
    unsigned char _field9;
    unsigned char _field10;
    unsigned char _field11;
    unsigned char _field12;
    long long _field13;
    long long _field14;
    long long _field15;
    unsigned char _field16;
    int _field17;
    long long _field18;
    id _field19;
    struct URLProtocolClient *_field20;
    struct _CFCachedURLResponse *_field21;
};

struct URLProtocolClient {
    CDUnknownFunctionPointerType *_field1;
};

struct UploadProgressInfo {
    long long _field1;
    long long _field2;
    long long _field3;
};

struct XCookieStorage {
    CDUnknownFunctionPointerType *_field1;
    struct __CFAllocator *_field2;
    int _field3;
};

struct XCredentialStorage {
    CDUnknownFunctionPointerType *_field1;
    struct __CFAllocator *_field2;
    int _field3;
};

struct XTubeManager {
    CDUnknownFunctionPointerType *_field1;
    struct __CFAllocator *_field2;
    int _field3;
    struct RetainableTypedDict<const CoreSchedulingSet *, TubeManager *> *_field4;
    struct _opaque_pthread_mutex_t _field5;
    struct HTTPConnectionCacheLimits _field6;
};

struct XURLCache {
    CDUnknownFunctionPointerType *_field1;
    struct __CFAllocator *_field2;
    int _field3;
};

struct _CFCachedURLResponse {
    struct __CFRuntimeBase _field1;
    struct __CFCachedURLResponse *_field2;
};

struct _CFHTTPAuthentication;

struct _CFURLCache {
    struct __CFRuntimeBase _field1;
    struct __CFURLCache *_field2;
};

struct __CFAllocator;

struct __CFArray;

struct __CFDictionary;

struct __CFRuntimeBase {
    unsigned long long _field1;
    unsigned char _field2[4];
    unsigned int _field3;
};

struct __CFSet;

struct __CFString;

struct __CFURLCache {
    CDUnknownFunctionPointerType *_field1;
    int *_field2;
    id _field3;
    CDUnknownBlockType _field4;
    id _field5;
    long long _field6;
    _Bool _field7;
    long long _field8;
    long long _field9;
    long long _field10;
    long long _field11;
    long long _field12;
    long long _field13;
    long long _field14;
    long long _field15;
    unsigned long long _field16;
    struct __CFString *_field17;
    struct __CFString *_field18;
    struct __CFString *_field19;
    char *_field20;
    _Bool _field21;
    _Bool _field22;
    struct sqlite3 *_field23;
    struct sqlite3 *_field24;
    struct _opaque_pthread_mutex_t _field25;
    struct _opaque_pthread_mutex_t _field26;
    struct CoreLockable *_field27;
    struct CoreLockable *_field28;
    struct CoreLockable *_field29;
    struct sqlite3_stmt *_field30;
    struct sqlite3_stmt *_field31;
    struct sqlite3_stmt *_field32;
    struct sqlite3_stmt *_field33;
    struct sqlite3_stmt *_field34;
    struct sqlite3_stmt *_field35;
    struct sqlite3_stmt *_field36;
    struct sqlite3_stmt *_field37;
    struct sqlite3_stmt *_field38;
    struct sqlite3_stmt *_field39;
    struct sqlite3_stmt *_field40;
    struct sqlite3_stmt *_field41;
    struct sqlite3_stmt *_field42;
    struct sqlite3_stmt *_field43;
    struct unordered_map<int, __CFURLCacheNode *, __CFURLCache__::HashFunc, std::__1::equal_to<int>, std::__1::allocator<std::__1::pair<const int, __CFURLCacheNode *>>> _field44;
    struct deque<__CFURLCacheNode *, std::__1::allocator<__CFURLCacheNode *>> _field45;
    struct __CFRunLoopSource *_field46;
    struct _opaque_pthread_t *_field47;
    struct _opaque_pthread_mutex_t _field48;
    struct _opaque_pthread_mutex_t _field49;
    struct _opaque_pthread_mutex_t _field50;
    struct _opaque_pthread_mutex_t _field51;
    struct _opaque_pthread_mutex_t _field52;
    struct __CFArray *_field53;
    struct __CFArray *_field54;
    _Bool _field55;
    _Bool _field56;
    id _field57;
    id _field58;
    _Bool _field59;
    id _field60;
    struct _CFURLCache *_field61;
    _Bool _field62;
    _Bool _field63;
    long long _field64;
    long long _field65;
    _Bool _field66;
    struct __asl_object_s *_field67;
    unsigned short _field68;
    long long _field69;
    _Bool _field70;
    _Bool _field71;
    _Bool _field72;
    _Bool _field73;
    long long _field74;
    _Bool _field75;
    _Bool _field76;
    long long _field77;
    id _field78;
    struct __CFSet *_field79;
    struct __CFArray *_field80;
    long long _field81;
    id _field82;
    struct _opaque_pthread_mutex_t _field83;
    struct _opaque_pthread_mutex_t _field84;
    struct __CFDictionary *_field85;
    _Bool _field86;
    struct bitset<32768> _field87;
    struct _opaque_pthread_mutex_t _field88;
    _Bool _field89;
    char *_field90;
    id _field91;
};

struct __CFURLCacheNode;

struct __hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>;

struct _opaque_pthread_mutex_t {
    long long _field1;
    char _field2[56];
};

struct _opaque_pthread_t;

struct bitset<32768> {
    unsigned long long _field1[512];
};

struct deque<__CFURLCacheNode *, std::__1::allocator<__CFURLCacheNode *>> {
    struct __split_buffer<__CFURLCacheNode **, std::__1::allocator<__CFURLCacheNode **>> {
        struct __CFURLCacheNode ***_field1;
        struct __CFURLCacheNode ***_field2;
        struct __CFURLCacheNode ***_field3;
        struct __compressed_pair<__CFURLCacheNode ***, std::__1::allocator<__CFURLCacheNode **>> {
            struct __CFURLCacheNode ***_field1;
        } _field4;
    } _field1;
    unsigned long long _field2;
    struct __compressed_pair<unsigned long, std::__1::allocator<__CFURLCacheNode *>> {
        unsigned long long _field1;
    } _field3;
};

struct internal_state;

struct sqlite3;

struct sqlite3_stmt;

struct stat {
    int st_dev;
    unsigned short st_mode;
    unsigned short st_nlink;
    unsigned long long st_ino;
    unsigned int st_uid;
    unsigned int st_gid;
    int st_rdev;
    struct timespec st_atimespec;
    struct timespec st_mtimespec;
    struct timespec st_ctimespec;
    struct timespec st_birthtimespec;
    long long st_size;
    long long st_blocks;
    int st_blksize;
    unsigned int st_flags;
    unsigned int st_gen;
    int st_lspare;
    long long st_qspare[2];
};

struct timespec {
    long long tv_sec;
    long long tv_nsec;
};

struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>*>>> {
        struct __hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *> **_field1;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>*>> {
                unsigned long long _field1;
            } _field1;
        } _field2;
    } _field1;
};

struct unordered_map<int, __CFURLCacheNode *, __CFURLCache__::HashFunc, std::__1::equal_to<int>, std::__1::allocator<std::__1::pair<const int, __CFURLCacheNode *>>> {
    struct __hash_table<std::__1::__hash_value_type<int, __CFURLCacheNode *>, std::__1::__unordered_map_hasher<int, std::__1::__hash_value_type<int, __CFURLCacheNode *>, __CFURLCache__::HashFunc, true>, std::__1::__unordered_map_equal<int, std::__1::__hash_value_type<int, __CFURLCacheNode *>, std::__1::equal_to<int>, true>, std::__1::allocator<std::__1::__hash_value_type<int, __CFURLCacheNode *>>> {
        struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>*>>> _field1;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>*>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *>*> {
                struct __hash_node<std::__1::__hash_value_type<int, __CFURLCacheNode *>, void *> *_field1;
            } _field1;
        } _field2;
        struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<int, std::__1::__hash_value_type<int, __CFURLCacheNode *>, __CFURLCache__::HashFunc, true>> {
            unsigned long long _field1;
        } _field3;
        struct __compressed_pair<float, std::__1::__unordered_map_equal<int, std::__1::__hash_value_type<int, __CFURLCacheNode *>, std::__1::equal_to<int>, true>> {
            float _field1;
        } _field4;
    } _field1;
};

struct z_stream_s {
    char *next_in;
    unsigned int avail_in;
    unsigned long long total_in;
    char *next_out;
    unsigned int avail_out;
    unsigned long long total_out;
    char *msg;
    struct internal_state *state;
    CDUnknownFunctionPointerType zalloc;
    CDUnknownFunctionPointerType zfree;
    void *opaque;
    int data_type;
    unsigned long long adler;
    unsigned long long reserved;
};

#pragma mark Typedef'd Structures

typedef struct {
    long long _field1;
    int _field2;
} CDStruct_87dc826d;

#pragma mark -

//
// File: /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/CFNetwork.framework/CFNetwork
// UUID: 647C46D9-843F-3386-B923-68B630F89234
//
//                           Arch: x86_64
//                Current version: 711.0.6
//          Compatibility version: 1.0.0
//                 Source version: 711.0.6.0.0
//            Minimum iOS version: 8.0.0
//                    SDK version: 8.0.0
//
// Objective-C Garbage Collection: Unsupported
//

@protocol NDBackgroundSessionClient <NSObject>
- (void)credStorage_setDefaultCredential:(NSURLCredential *)arg1 forProtectionSpace:(NSURLProtectionSpace *)arg2;
- (void)credStorage_defaultCredentialForProtectionSpace:(NSURLProtectionSpace *)arg1 reply:(void (^)(NSURLCredential *))arg2;
- (void)credStorage_removeCredential:(NSURLCredential *)arg1 forProtectionSpace:(NSURLProtectionSpace *)arg2;
- (void)credStorage_setCredential:(NSURLCredential *)arg1 forProtectionSpace:(NSURLProtectionSpace *)arg2;
- (void)credStorage_allCredentialsWithReply:(void (^)(NSDictionary *))arg1;
- (void)credStorage_credentialsForProtectionSpace:(NSURLProtectionSpace *)arg1 reply:(void (^)(NSDictionary *))arg2;
- (void)credStorage_getInitialCredentialDictionariesWithReply:(void (^)(NSDictionary *, NSDictionary *))arg1;
- (void)backgroundSessionDidFinishAppWake:(NSString *)arg1 reply:(void (^)(void))arg2;
- (void)backgroundSessionDidStartAppWake:(NSString *)arg1 reply:(void (^)(void))arg2;
- (void)backgroundAVAssetDownloadTask:(unsigned long long)arg1 didReceiveDownloadToken:(unsigned long long)arg2;
- (void)backgroundAVAssetDownloadTaskDidUpdateProgress:(unsigned long long)arg1 totalBytesWritten:(unsigned long long)arg2 totalBytesExpectedToWrite:(unsigned long long)arg3;
- (void)openFileAtPath:(NSString *)arg1 mode:(int)arg2 withReply:(void (^)(NSFileHandle *))arg3;
- (void)backgroundDownloadTask:(unsigned long long)arg1 didFinishDownloadingToURL:(NSURL *)arg2 reply:(void (^)(void))arg3;
- (void)backgroundDownloadTask:(unsigned long long)arg1 didResumeAtOffset:(long long)arg2 expectedTotalBytes:(long long)arg3;
- (void)backgroundDownloadTask:(unsigned long long)arg1 didWriteData:(long long)arg2 totalBytesWritten:(long long)arg3 totalBytesExpectedToWrite:(long long)arg4;
- (void)willRetryBackgroundDataTask:(unsigned long long)arg1 withError:(NSError *)arg2 timingData:(NSDictionary *)arg3;
- (void)backgroundDataTaskDidBecomeDownloadTask:(unsigned long long)arg1;
- (void)backgroundDataTask:(unsigned long long)arg1 didReceiveData:(NSData *)arg2 withReply:(void (^)(void))arg3;
- (void)backgroundTask:(unsigned long long)arg1 didCompleteWithError:(NSError *)arg2 timingData:(NSDictionary *)arg3 reply:(void (^)(void))arg4;
- (void)backgroundTask:(unsigned long long)arg1 needNewBodyStream:(_Bool)arg2 withReply:(void (^)(NSFileHandle *))arg3;
- (void)backgroundTask:(unsigned long long)arg1 didSendBodyData:(long long)arg2 totalBytesSent:(long long)arg3 totalBytesExpectedToSend:(long long)arg4;
- (void)backgroundTask:(unsigned long long)arg1 didReceiveResponse:(NSURLResponse *)arg2 timingData:(NSDictionary *)arg3 reply:(void (^)(long long))arg4;
- (void)backgroundTask:(unsigned long long)arg1 didReceiveResponse:(NSURLResponse *)arg2 timingData:(NSDictionary *)arg3;
- (void)backgroundTaskHasConnectionWaiting:(unsigned long long)arg1;
- (void)backgroundTask:(unsigned long long)arg1 _willSendRequestForEstablishedConnection:(NSURLRequest *)arg2 reply:(void (^)(NSURLRequest *, NSFileHandle *))arg3;
- (void)backgroundTask:(unsigned long long)arg1 willPerformHTTPRedirectionWithNewRequest:(NSURLRequest *)arg2 reply:(void (^)(NSURLRequest *))arg3;
- (void)backgroundTask:(unsigned long long)arg1 didReceiveChallenge:(NSURLAuthenticationChallenge *)arg2 reply:(void (^)(long long, NSURLCredential *))arg3;
- (void)backgroundTaskDidSuspend:(unsigned long long)arg1;
- (void)backgroundTaskDidResume:(unsigned long long)arg1;
@end

@protocol NDBackgroundSessionManagerProtocol <NSObject>
- (void)obliterateAllSessionsWithReply:(void (^)(void))arg1;
- (void)getActiveSessionIdentifiersWithReply:(void (^)(NSArray *))arg1;
- (void)okayToSendPendingCallbacksForIdentifier:(NSString *)arg1 reply:(void (^)(void))arg2;
- (void)releaseAssertionForSession:(NSString *)arg1 reply:(void (^)(void))arg2;
- (void)sendPendingCallbacksForIdentifier:(NSString *)arg1 reply:(void (^)(void))arg2;
- (void)createSessionWithConfiguration:(NSURLSessionConfiguration *)arg1 clientProxy:(id <NDBackgroundSessionClient>)arg2 cachesDirectory:(NSURL *)arg3 options:(NSDictionary *)arg4 reply:(void (^)(id <NDBackgroundSessionProtocol>, NSDictionary *, _Bool))arg5;
- (void)dropBoost;
- (void)boost;
@end

@protocol NDBackgroundSessionProtocol <NSObject>
- (void)avAssetDownloadTaskWithURL:(NSURL *)arg1 destinationURL:(NSURL *)arg2 options:(NSDictionary *)arg3 identifier:(unsigned long long)arg4 reply:(void (^)(_Bool))arg5;
- (void)invalidateWithReply:(void (^)(void))arg1;
- (void)resetStorageWithReply:(void (^)(void))arg1;
- (void)setPriority:(long long)arg1 forTaskWithIdentifier:(unsigned long long)arg2;
- (void)setDescription:(NSString *)arg1 forTask:(unsigned long long)arg2;
- (void)resumeTaskWithIdentifier:(unsigned long long)arg1;
- (void)suspendTaskWithIdentifier:(unsigned long long)arg1;
- (void)cancelTaskWithIdentifier:(unsigned long long)arg1 byProducingResumeData:(void (^)(NSData *))arg2;
- (void)cancelTaskWithIdentifier:(unsigned long long)arg1;
- (void)downloadTaskWithResumeData:(NSData *)arg1 identifier:(unsigned long long)arg2 reply:(void (^)(_Bool))arg3;
- (void)dataTaskWithRequest:(NSURLRequest *)arg1 originalRequest:(NSURLRequest *)arg2 identifier:(unsigned long long)arg3 reply:(void (^)(_Bool))arg4;
- (void)uploadTaskWithRequest:(NSURLRequest *)arg1 originalRequest:(NSURLRequest *)arg2 fromFile:(NSURL *)arg3 sandboxExtensionData:(NSData *)arg4 identifier:(unsigned long long)arg5 reply:(void (^)(_Bool))arg6;
- (void)downloadTaskWithRequest:(NSURLRequest *)arg1 originalRequest:(NSURLRequest *)arg2 downloadFilePath:(NSString *)arg3 identifier:(unsigned long long)arg4 reply:(void (^)(_Bool))arg5;
@end

@protocol NSCoding
- (id)initWithCoder:(NSCoder *)arg1;
- (void)encodeWithCoder:(NSCoder *)arg1;
@end

@protocol NSCopying
- (id)copyWithZone:(struct _NSZone *)arg1;
@end

@protocol NSMutableCopying
- (id)mutableCopyWithZone:(struct _NSZone *)arg1;
@end

@protocol NSObject
@property(readonly, copy) NSString *description;
@property(readonly) Class superclass;
@property(readonly) unsigned long long hash;
- (struct _NSZone *)zone;
- (unsigned long long)retainCount;
- (id)autorelease;
- (oneway void)release;
- (id)retain;
- (_Bool)respondsToSelector:(SEL)arg1;
- (_Bool)conformsToProtocol:(Protocol *)arg1;
- (_Bool)isMemberOfClass:(Class)arg1;
- (_Bool)isKindOfClass:(Class)arg1;
- (_Bool)isProxy;
- (id)performSelector:(SEL)arg1 withObject:(id)arg2 withObject:(id)arg3;
- (id)performSelector:(SEL)arg1 withObject:(id)arg2;
- (id)performSelector:(SEL)arg1;
- (id)self;
- (Class)class;
- (_Bool)isEqual:(id)arg1;

@optional
@property(readonly, copy) NSString *debugDescription;
@end

@protocol NSSecureCoding <NSCoding>
+ (_Bool)supportsSecureCoding;
@end

@protocol NSStreamDelegate <NSObject>

@optional
- (void)stream:(NSStream *)arg1 handleEvent:(unsigned long long)arg2;
@end

@protocol NSURLAuthenticationChallengeSender <NSObject>
- (void)cancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)arg1;
- (void)continueWithoutCredentialForAuthenticationChallenge:(NSURLAuthenticationChallenge *)arg1;
- (void)useCredential:(NSURLCredential *)arg1 forAuthenticationChallenge:(NSURLAuthenticationChallenge *)arg2;

@optional
- (void)rejectProtectionSpaceAndContinueWithChallenge:(NSURLAuthenticationChallenge *)arg1;
- (void)performDefaultHandlingForAuthenticationChallenge:(NSURLAuthenticationChallenge *)arg1;
@end

@protocol NSURLConnectionRequired <NSObject>

@optional
- (void)_setShouldSkipCancelOnRelease:(_Bool)arg1;
- (void)_resumeLoading;
- (void)_suspendLoading;
- (void)_setDelegateQueue:(NSOperationQueue *)arg1;
- (void)unscheduleFromRunLoop:(NSRunLoop *)arg1 forMode:(NSString *)arg2;
- (void)scheduleInRunLoop:(NSRunLoop *)arg1 forMode:(NSString *)arg2;
- (void)cancel;
- (void)start;
@end

@protocol NSURLDownloadDecoder <NSObject>
- (NSString *)filenameWithOriginalFilename:(NSString *)arg1;
@end

@protocol NSURLProtocolClient <NSObject>
- (void)URLProtocol:(NSURLProtocol *)arg1 didCancelAuthenticationChallenge:(NSURLAuthenticationChallenge *)arg2;
- (void)URLProtocol:(NSURLProtocol *)arg1 didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)arg2;
- (void)URLProtocol:(NSURLProtocol *)arg1 didFailWithError:(NSError *)arg2;
- (void)URLProtocolDidFinishLoading:(NSURLProtocol *)arg1;
- (void)URLProtocol:(NSURLProtocol *)arg1 didLoadData:(NSData *)arg2;
- (void)URLProtocol:(NSURLProtocol *)arg1 didReceiveResponse:(NSURLResponse *)arg2 cacheStoragePolicy:(unsigned long long)arg3;
- (void)URLProtocol:(NSURLProtocol *)arg1 cachedResponseIsValid:(NSCachedURLResponse *)arg2;
- (void)URLProtocol:(NSURLProtocol *)arg1 wasRedirectedToRequest:(NSURLRequest *)arg2 redirectResponse:(NSURLResponse *)arg3;
@end

@protocol NSURLSessionDataTaskSubclass <NSURLSessionTaskSubclass>
@end

@protocol NSURLSessionDownloadTaskSubclass <NSURLSessionDataTaskSubclass>
- (void)_onqueue_cancelByProducingResumeData:(void (^)(NSData *))arg1;
@end

@protocol NSURLSessionStreamTaskSubclass <NSURLSessionTaskSubclass>
@end

@protocol NSURLSessionSubclass <NSObject>
- (void)_onqueue_getTasksWithCompletionHandler:(void (^)(NSArray *, NSArray *, NSArray *))arg1;
- (void)_onqueue_resetStorageWithCompletionHandler:(void (^)(void))arg1;
- (void)_onqueue_completeInvalidation:(_Bool)arg1;
- (void)_onqueue_flushWithCompletionHandler:(void (^)(void))arg1;
- (NSURLSessionStreamTask *)_streamTaskForHost:(NSString *)arg1 port:(long long)arg2 tls:(_Bool)arg3 completionHandler:(void (^)(NSInputStream *, NSOutputStream *))arg4;
- (NSURLSessionAVAssetDownloadTask *)_AVAssetDownloadTaskForURL:(NSURL *)arg1 destinationURL:(NSURL *)arg2 options:(NSDictionary *)arg3;
- (NSURLSessionDownloadTask *)downloadTaskForRequest:(NSURLRequest *)arg1 downloadFilePath:(NSString *)arg2 resumeData:(NSData *)arg3 completion:(void (^)(NSURL *, NSURLResponse *, NSError *))arg4;
- (NSURLSessionUploadTask *)uploadTaskForRequest:(NSURLRequest *)arg1 uploadFile:(NSURL *)arg2 bodyData:(NSData *)arg3 completion:(void (^)(NSData *, NSURLResponse *, NSError *))arg4;
- (NSURLSessionDataTask *)dataTaskForRequest:(NSURLRequest *)arg1 completion:(void (^)(NSData *, NSURLResponse *, NSError *))arg2;
@end

@protocol NSURLSessionTaskSubclass <NSObject>
- (void)_onqueue_disavow;
- (void)_onqueue_adjustPoolPriority;
- (void)_onqueue_resume;
- (void)_onqueue_suspend;
- (void)_onqueue_cancel;
@end

@protocol NSURLSessionUploadTaskSubclass <NSURLSessionDataTaskSubclass>
@end

@protocol NSURLStorageCacheClient
- (void)notifyCachedURLResponseBecameFileBacked:(NSString *)arg1 filePath:(NSString *)arg2 forUUID:(NSString *)arg3;
@end

@protocol NetworkStorageXPCProtocol
- (void)setMinSizeForVMCachedResource:(long long)arg1 withIdentifier:(NSString *)arg2;
- (void)currentDiskUsageWithIdentifier:(NSString *)arg1 completionHandler:(void (^)(long long))arg2;
- (void)setMaxSize:(long long)arg1 withIdentifier:(NSString *)arg2;
- (void)copyAllPartitionNamesWithIdentifier:(NSString *)arg1 completionHandler:(void (^)(NSArray *))arg2;
- (void)copyAllHostNamesForOptionalPartition:(NSString *)arg1 identifier:(NSString *)arg2 completionHandler:(void (^)(NSArray *))arg3;
- (void)deleteAllHostNames:(NSArray *)arg1 forOptionalPartition:(NSString *)arg2 identifier:(NSString *)arg3;
- (void)deleteResponsesSinceDate:(NSDate *)arg1 withIdentifier:(NSString *)arg2;
- (void)deleteAllResponsesWithIdentifier:(NSString *)arg1;
- (void)deleteResponseForRequestWithKey:(NSString *)arg1 withIdentifier:(NSString *)arg2 completionHandler:(void (^)(_Bool))arg3;
- (void)addCachedResponseWithDictionary:(NSDictionary *)arg1 identifier:(NSString *)arg2 key:(NSString *)arg3;
- (void)addCachedResponse:(NSData *)arg1 identifier:(NSString *)arg2 key:(NSString *)arg3;
- (void)cachedResponseForKey:(NSString *)arg1 withIdentifier:(NSString *)arg2 handler:(void (^)(NSCachedURLResponse *, NSString *, NSString *))arg3;
- (void)storageTaskManagerExistsWithIdentifier:(NSString *)arg1 completionHandler:(void (^)(_Bool))arg2;
- (void)createStorageTaskManagerForPath:(NSString *)arg1 maxSize:(long long)arg2 extension:(NSData *)arg3 withIdentifier:(NSString *)arg4;
@end

@protocol SSDownloadHandlerDelegate <NSObject>

@optional
- (void)downloadHandler:(SSDownloadHandler *)arg1 handleAuthenticationSession:(SSDownloadAuthenticationSession *)arg2;
- (_Bool)downloadHandler:(SSDownloadHandler *)arg1 pauseSession:(SSDownloadSession *)arg2;
- (void)downloadHandler:(SSDownloadHandler *)arg1 cancelSession:(SSDownloadSession *)arg2;
- (void)downloadHandler:(SSDownloadHandler *)arg1 handleSession:(SSDownloadHandlerSession *)arg2;
- (void)downloadHandlerDidDisconnect:(SSDownloadHandler *)arg1;
@end

@protocol SSDownloadManagerObserver <NSObject>

@optional
- (void)downloadManagerNetworkUsageDidChange:(SSDownloadManager *)arg1;
- (void)downloadManagerDownloadsDidChange:(SSDownloadManager *)arg1;
- (void)downloadManagerActiveDownloadsDidChange:(SSDownloadManager *)arg1;
- (void)downloadManager:(SSDownloadManager *)arg1 downloadStatesDidChange:(NSArray *)arg2;
@end

@protocol SessionConnectionDelegate <NSObject, NSCopying>
- (void)connection:(__NSCFURLSessionConnection *)arg1 _conditionalRequirementsChanged:(_Bool)arg2;
- (void)connectionWaiting:(__NSCFURLSessionConnection *)arg1;
- (void)connection:(__NSCFURLSessionConnection *)arg1 _willSendRequestForEstablishedConnection:(NSURLRequest *)arg2 completion:(void (^)(NSURLRequest *))arg3;
- (void)connection:(__NSCFURLSessionConnection *)arg1 sentBodyBytes:(NSNumber *)arg2 totalBytes:(NSNumber *)arg3 expectedBytes:(NSNumber *)arg4;
- (void)connection:(__NSCFURLSessionConnection *)arg1 didReceiveData:(NSObject<OS_dispatch_data> *)arg2 completion:(void (^)(void))arg3;
- (void)connection:(__NSCFURLSessionConnection *)arg1 challenged:(NSURLAuthenticationChallenge *)arg2 authCallback:(void (^)(long long, NSURLCredential *))arg3;
- (void)connection:(__NSCFURLSessionConnection *)arg1 didReceiveConnectionCacheKey:(struct HTTPConnectionCacheKey *)arg2;
- (void)connection:(__NSCFURLSessionConnection *)arg1 didFinishLoadingWithError:(NSError *)arg2;
- (void)connectionWillFinishLoading:(__NSCFURLSessionConnection *)arg1;
- (void)connection:(__NSCFURLSessionConnection *)arg1 willCacheResponse:(NSCachedURLResponse *)arg2 responseCallback:(void (^)(NSCachedURLResponse *))arg3;
- (void)connection:(__NSCFURLSessionConnection *)arg1 didReceiveResponse:(NSURLResponse *)arg2 completion:(void (^)(struct SessionResponseOptions))arg3;
- (void)connection:(__NSCFURLSessionConnection *)arg1 request:(NSURLRequest *)arg2 needsNewBodyStreamCallback:(void (^)(NSInputStream *))arg3;
- (void)connection:(__NSCFURLSessionConnection *)arg1 wasRedirected:(NSHTTPURLResponse *)arg2 newRequest:(NSURLRequest *)arg3 responseCallback:(void (^)(NSURLRequest *))arg4;
@end

@protocol __NSCFLocalDownloadFileOpener
- (int)openItemForPath:(NSString *)arg1 mode:(int)arg2;
@end

__attribute__((visibility("hidden")))
@interface CONNECTION_SessionTask : NSObject
{
    struct _CFURLRequest *_originalRequest;
    struct _CFURLRequest *_currentRequest;
    struct __CFDictionary *_connectionProperties;
    struct __CFDictionary *_socketProperties;
    NSMutableURLRequest *_nsCurrentRequest;
    NSURLRequest *_nsOriginalRequest;
    NSURLSession *_session;
    _Bool _is_cellular;
    Class _my_protocolForTask;
}

- (_Bool)_shouldSkipPreferredClientCertificateLookup;
- (id)_protocolForTask;
- (void)set_protocolForTask:(id)arg1;
- (void)_setConnectionIsCellular:(_Bool)arg1;
- (float)priority;
- (void)_releasePreventIdleSleepAssertionIfAppropriate;
- (void)_takePreventIdleSleepAssertionIfAppropriate;
- (double)_timeoutInterval;
- (long long)_suspensionThreshhold;
- (unsigned char)_strictContentLength;
- (struct __CFDictionary *)_sslSettings;
- (unsigned char)_shouldUsePipelineHeuristics;
- (unsigned char)_shouldSkipPipelineProbe;
- (unsigned char)_shouldPipelineHTTP;
- (long long)_requestPriority;
- (struct __CFDictionary *)_proxySettings;
- (unsigned char)_preventsIdleSystemSleep;
- (int)_cachePolicy;
- (unsigned long long)_allowedProtocolTypes;
- (struct __CFDictionary *)_additionalHeaders;
- (id)_timeWindowDuration;
- (id)_timeWindowDelay;
- (id)_expectedWorkload;
- (id)_disallowCellular;
- (id)_boundInterfaceIdentifier;
- (id)_prohibitAuthUI;
- (id)_networkServiceType;
- (id)_allowsCellular;
- (id)_contentDispositionFallbackArray;
- (id)_cookieAcceptPolicy;
- (id)_shouldHandleCookies;
- (id)_cfCookies;
- (id)_cfCreds;
- (id)_cfCache;
- (id)_cfHSTS;
- (id)_backgroundTaskTimingData;
- (id)_connectionPropertyDuet;
- (id)_performanceTiming;
- (id)_priorityValue;
- (id)startTime;
- (id)error;
- (id)state;
- (id)countOfBytesExpectedToReceive;
- (id)countOfBytesExpectedToSend;
- (id)countOfBytesSent;
- (id)countOfBytesReceived;
- (id)taskIdentifier;
- (struct __CFURL *)originalRequest_mainDocumentURL;
- (struct __CFURL *)currentRequest_URL;
- (id)originalRequest;
- (id)currentRequest;
- (struct _CFURLRequest *)_currentCFURLRequest;
- (id)workQueue;
- (id)session;
- (struct __CFHTTPMessage *)_copyHTTPMessage;
- (_Bool)shouldHandleCookiesAndSchemeIsAppropriate;
- (void)_setSocketProperties:(struct __CFDictionary *)arg1 connectionProperties:(struct __CFDictionary *)arg2;
- (const struct XCredentialStorage *)_createXCredentialStorage;
- (const struct XCookieStorage *)_createXCookieStorage;
- (const struct XURLCache *)_createXURLCache;
- (struct _CFHSTSPolicy *)_copyHSTSPolicy;
- (void)cleanupAndBreakCycles;
- (void)_initializeTimingDataWithSessionConfiguration:(id)arg1;
- (struct __CFDictionary *)_copySocketStreamProperties;
- (void)updateCurrentRequest:(id)arg1;
- (struct _CFURLRequest *)_copyOriginalCFURLRequest;
- (struct _CFURLRequest *)_copyCurrentCFURLRequest;
- (void)dealloc;
- (id)initWithRequest:(struct _CFURLRequest *)arg1 mutableCurrent:(struct _CFURLRequest *)arg2 connProps:(struct __CFDictionary *)arg3 sockProps:(struct __CFDictionary *)arg4 session:(id)arg5;

@end

@interface NSURLProtocol : NSObject
{
    NSURLProtocolInternal *_internal;
}

+ (_Bool)canInitWithTask:(id)arg1;
+ (void)removePropertyForKey:(id)arg1 inRequest:(id)arg2;
+ (void)setProperty:(id)arg1 forKey:(id)arg2 inRequest:(id)arg3;
+ (id)propertyForKey:(id)arg1 inRequest:(id)arg2;
+ (void)unregisterClass:(Class)arg1;
+ (_Bool)registerClass:(Class)arg1;
+ (_Bool)requestIsCacheEquivalent:(id)arg1 toRequest:(id)arg2;
+ (id)canonicalRequestForRequest:(id)arg1 task:(id)arg2;
+ (id)canonicalRequestForRequest:(id)arg1;
+ (_Bool)canInitWithRequest:(id)arg1;
+ (id)_makeRequestCanonicalByMakingRequestURLCanonical:(id)arg1;
+ (Class)_protocolClassForRequest:(id)arg1;
- (id)initWithTask:(id)arg1 cachedResponse:(id)arg2 client:(id)arg3;
- (void)stopLoading;
- (void)startLoading;
- (void)dealloc;
@property(readonly, copy) NSCachedURLResponse *cachedResponse;
@property(readonly, copy) NSURLRequest *request;
@property(readonly, retain) id <NSURLProtocolClient> client;
- (id)initWithRequest:(id)arg1 cachedResponse:(id)arg2 client:(id)arg3;

@end

__attribute__((visibility("hidden")))
@interface NSAboutURLProtocol : NSURLProtocol
{
}

+ (id)canonicalRequestForRequest:(id)arg1;
+ (_Bool)canInitWithRequest:(id)arg1;
- (void)stopLoading;
- (void)startLoading;

@end

__attribute__((visibility("hidden")))
@interface NSAsyncSSDownloadManager : NSObject <SSDownloadManagerObserver>
{
    SSDownloadManager *_manager;
    NSOperationQueue *_queue;
    NSMutableDictionary *_downloads;
    _Bool _reconnectInProgress;
}

- (void)downloadHandlerDisconnected:(_Bool)arg1;
- (void)_attemptReconnect;
- (void)addDownload:(id)arg1 completionBlock:(CDUnknownBlockType)arg2;
- (void)addDownloads:(id)arg1 completionBlock:(CDUnknownBlockType)arg2;
- (void)finishDownload:(long long)arg1;
- (void)withDownloadMatchingIdentifier:(id)arg1 perform:(CDUnknownBlockType)arg2;
- (void)cancelDownload:(long long)arg1 completionBlock:(CDUnknownBlockType)arg2;
- (void)downloadManagerDownloadsDidChange:(id)arg1;
- (void)downloadManager:(id)arg1 downloadStatesDidChange:(id)arg2;
- (void)withDownload:(long long)arg1 performAsync:(CDUnknownBlockType)arg2;
- (void)withDownload:(long long)arg1 perform:(CDUnknownBlockType)arg2;
- (void)addOperationWithBlock:(CDUnknownBlockType)arg1;
- (void)setDelegate:(id)arg1 forDownload:(long long)arg2;
- (void)dealloc;
- (id)initWithDownloadManager:(id)arg1;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

@interface NSCachedURLResponse : NSObject <NSSecureCoding, NSCopying>
{
    NSCachedURLResponseInternal *_internal;
}

+ (void)initialize;
+ (_Bool)supportsSecureCoding;
- (void)_reestablishInternalCFCachedURLResponse:(struct _CFCachedURLResponse *)arg1;
- (void)_deallocInternalCFCachedURLResponse;
- (struct _CFCachedURLResponse *)_CFCachedURLResponse;
- (void)dealloc;
@property(readonly) unsigned long long storagePolicy;
@property(readonly, copy) NSDictionary *userInfo;
- (id)dataArray;
@property(readonly, copy) NSData *data;
@property(readonly, copy) NSURLResponse *response;
- (void)encodeWithCoder:(id)arg1;
- (void)_private_encodeWithCoder:(id)arg1;
- (id)initWithCoder:(id)arg1;
- (id)_private_initWithCoder:(id)arg1;
- (id)copyWithZone:(struct _NSZone *)arg1;
- (id)_initWithCFCachedURLResponse:(struct _CFCachedURLResponse *)arg1;
- (id)initWithResponse:(id)arg1 dataArray:(id)arg2 userInfo:(id)arg3 storagePolicy:(unsigned long long)arg4;
- (id)initWithResponse:(id)arg1 data:(id)arg2 userInfo:(id)arg3 storagePolicy:(unsigned long long)arg4;
- (id)initWithResponse:(id)arg1 data:(id)arg2;

@end

__attribute__((visibility("hidden")))
@interface NSCachedURLResponseInternal : NSObject
{
    NSURLResponse *response;
    NSData *data;
    NSDictionary *userInfo;
    unsigned long long storagePolicy;
    struct _CFCachedURLResponse *_cachedURLResponse;
}

- (void)dealloc;

@end

@interface NSData (NSURLSession_Additions)
- (_Bool)_isSafeResumeDataForBackgroundDownload:(int)arg1;
@end

@interface NSGZipDecoder : NSObject <NSURLDownloadDecoder>
{
    struct z_stream_s _stream;
    unsigned long long _modificationTime;
    NSString *_filename;
    _Bool _streamInitialized;
    _Bool _decodedHeader;
    _Bool _finishedInflating;
    _Bool _pad;
}

+ (id)MIMEType;
+ (_Bool)canDecodeDownloadHeaderData:(id)arg1;
+ (_Bool)decodeDownloadHeader:(id)arg1 headerLength:(int *)arg2 modificationTime:(unsigned long long *)arg3 filename:(id *)arg4;
- (id).cxx_construct;
- (id)filenameWithOriginalFilename:(id)arg1;
- (id)fileAttributes;
- (_Bool)finishDownloadDecoding;
- (_Bool)isFinishedDecoding;
- (_Bool)decodeDownloadData:(id)arg1 dataForkData:(id *)arg2 resourceForkData:(id *)arg3;
- (id)decodeData:(id)arg1;
- (void)finalize;
- (void)dealloc;
- (id)init;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

@interface NSHTTPCookie : NSObject
{
    NSHTTPCookieInternal *_cookiePrivate;
}

+ (id)cookiesWithResponseHeaderFields:(id)arg1 forURL:(id)arg2;
+ (id)requestHeaderFieldsWithCookies:(id)arg1;
+ (struct __CFArray *)_ns2cfCookies:(id)arg1;
+ (id)_cf2nsCookies:(struct __CFArray *)arg1;
+ (id)cookieWithCFHTTPCookie:(struct OpaqueCFHTTPCookie *)arg1;
+ (id)cookieWithProperties:(id)arg1;
- (id)initWithCoder:(id)arg1;
- (void)encodeWithCoder:(id)arg1;
- (unsigned long long)hash;
- (_Bool)isEqual:(id)arg1;
- (id)description;
- (_Bool)_isExpired;
- (id)_key;
- (long long)_compareForHeaderOrder:(id)arg1;
- (id)MaxAge;
- (id)Port;
- (id)Discard;
- (id)Secure;
- (id)Version;
- (id)OriginURL;
- (id)CommentURL;
- (id)Comment;
- (id)Expires;
- (id)Path;
- (id)Domain;
- (id)Value;
- (id)Name;
@property(readonly, copy) NSArray *portList;
@property(readonly, copy) NSURL *commentURL;
@property(readonly, copy) NSString *comment;
@property(readonly, copy) NSString *path;
@property(readonly, copy) NSString *domain;
@property(readonly, copy) NSString *value;
@property(readonly, copy) NSString *name;
@property(readonly, copy) NSDate *expiresDate;
@property(readonly, getter=isHTTPOnly) _Bool HTTPOnly;
@property(readonly, getter=isSecure) _Bool secure;
@property(readonly, getter=isSessionOnly) _Bool sessionOnly;
@property(readonly) unsigned long long version;
- (struct OpaqueCFHTTPCookie *)_CFHTTPCookie;
- (struct OpaqueCFHTTPCookie *)_GetInternalCFHTTPCookie;
@property(readonly, copy) NSDictionary *properties;
- (void)finalize;
- (void)dealloc;
- (id)init;
- (id)initWithCFHTTPCookie:(struct OpaqueCFHTTPCookie *)arg1;
- (id)initWithProperties:(id)arg1;

@end

@interface NSHTTPCookieStorage : NSObject
{
    NSHTTPCookieStorageInternal *_internal;
}

+ (id)sharedHTTPCookieStorage;
- (void)getCookiesForTask:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (void)storeCookies:(id)arg1 forTask:(id)arg2;
- (id)sortedCookiesUsingDescriptors:(id)arg1;
- (id)description;
@property unsigned long long cookieAcceptPolicy;
- (void)setCookies:(id)arg1 forURL:(id)arg2 mainDocumentURL:(id)arg3;
- (id)_cookiesForURL:(id)arg1 mainDocumentURL:(id)arg2;
- (id)cookiesForURL:(id)arg1;
- (void)setCookiesFromResponseHeader:(id)arg1 forURL:(id)arg2 policyBaseURL:(id)arg3;
- (id)cookieRequestHeaderFieldsForURL:(id)arg1;
- (void)removeCookiesSinceDate:(id)arg1;
- (void)deleteCookie:(id)arg1;
- (void)setCookie:(id)arg1;
@property(readonly, copy) NSArray *cookies;
- (struct OpaqueCFHTTPCookieStorage *)_CFHTTPCookieStorage;
- (void)dealloc;
- (id)init;
- (id)_initWithCFHTTPCookieStorage:(struct OpaqueCFHTTPCookieStorage *)arg1;
- (void)_saveCookies;
- (struct OpaqueCFHTTPCookieStorage *)_cookieStorage;
- (void)_setPrivateBrowsingEnabled:(_Bool)arg1;
- (id)_initWithIdentifier:(id)arg1 private:(_Bool)arg2;

@end

__attribute__((visibility("hidden")))
@interface NSHTTPCookieStorageInternal : NSObject
{
    struct OpaqueCFHTTPCookieStorage *storage;
    struct OpaqueCFHTTPCookieStorage *privateStorage;
    NSRecursiveLock *dataLock;
    _Bool privateBrowsing;
}

- (void)dealloc;
- (void)_syncCookies;
- (id)initInternalWithCFStorage:(struct OpaqueCFHTTPCookieStorage *)arg1;
- (void)registerForPostingNotifications;
- (id)_initWithIdentifier:(id)arg1 private:(_Bool)arg2;

@end

__attribute__((visibility("hidden")))
@interface NSHTTPURLRequestParameters : NSObject
{
    NSString *method;
    NSMutableDictionary *fields;
    NSArray *extraCookies;
    NSData *data;
    unsigned long long pageNotFoundCacheLifetime;
    _Bool shouldHandleCookies;
    _Bool _pad1;
    _Bool _pad2;
    _Bool _pad3;
}

- (void)dealloc;
- (id)initWithCoder:(id)arg1;
- (id)init;

@end

@interface NSURLResponse : NSObject <NSSecureCoding, NSCopying>
{
    NSURLResponseInternal *_internal;
}

+ (_Bool)supportsSecureCoding;
+ (id)getObjectKeyWithIndex:(long long)arg1;
+ (id)_responseWithCFURLResponse:(struct _CFURLResponse *)arg1;
- (id)copyWithZone:(struct _NSZone *)arg1;
@property(readonly, copy) NSString *suggestedFilename;
@property(readonly) long long expectedContentLength;
@property(readonly, copy) NSString *textEncodingName;
@property(readonly, copy) NSString *MIMEType;
@property(readonly, copy) NSURL *URL;
- (id)description;
- (void)encodeWithCoder:(id)arg1;
- (id)initWithCoder:(id)arg1;
- (id)init;
- (id)initWithURL:(id)arg1 MIMEType:(id)arg2 expectedContentLength:(long long)arg3 textEncodingName:(id)arg4;
- (id)_initWithCFURLResponse:(struct _CFURLResponse *)arg1;
- (id)_peerCertificateChain;
- (void)dealloc;
- (double)_calculatedExpiration;
- (double)_freshnessLifetime;
- (_Bool)_mustRevalidate;
- (id)_lastModifiedDate;
- (void)_setMIMEType:(id)arg1;
- (void)_setExpectedContentLength:(long long)arg1;
- (struct _CFURLResponse *)_CFURLResponse;

@end

@interface NSHTTPURLResponse : NSURLResponse
{
    NSHTTPURLResponseInternal *_httpInternal;
}

+ (_Bool)isErrorStatusCode:(long long)arg1;
+ (id)localizedStringForStatusCode:(long long)arg1;
+ (_Bool)supportsSecureCoding;
- (struct __SecTrust *)_peerTrust;
- (void)_setPeerTrust:(struct __SecTrust *)arg1;
- (id)_clientCertificateState;
- (id)_clientCertificateChain;
- (id)_peerCertificateChain;
- (void)dealloc;
@property(readonly) long long statusCode;
@property(readonly, copy) NSDictionary *allHeaderFields;
- (id)description;
- (void)encodeWithCoder:(id)arg1;
- (id)initWithCoder:(id)arg1;
- (id)initWithURL:(id)arg1 statusCode:(long long)arg2 HTTPVersion:(id)arg3 headerFields:(id)arg4;
- (id)initWithURL:(id)arg1 statusCode:(long long)arg2 headerFields:(id)arg3 requestTime:(double)arg4;
- (id)_initWithCFURLResponse:(struct _CFURLResponse *)arg1;

@end

__attribute__((visibility("hidden")))
@interface NSHTTPURLResponseInternal : NSObject <NSCoding>
{
    struct __SecTrust *peerTrust;
    _Bool isMixedReplace;
}

- (void)dealloc;
- (void)encodeWithCoder:(id)arg1;
- (id)initWithCoder:(id)arg1;

@end

@interface NSHost : NSObject
{
    NSArray *names;
    NSArray *addresses;
    id reserved;
}

+ (void)flushHostCache;
+ (void)setHostCacheEnabled:(_Bool)arg1;
+ (_Bool)isHostCacheEnabled;
+ (id)hostWithAddress:(id)arg1;
+ (id)hostWithName:(id)arg1;
+ (id)currentHost;
@property(retain, nonatomic) __NSHostExtraIvars *reserved; // @synthesize reserved;
- (void)dealloc;
- (id)description;
@property(readonly, copy) NSString *localizedName;
@property(readonly, copy) NSArray *addresses;
@property(readonly, copy) NSString *address;
@property(readonly, copy) NSArray *names;
@property(readonly, copy) NSString *name;
- (_Bool)isEqualToHost:(id)arg1;
- (void)resolveCurrentHostWithHandler:(CDUnknownBlockType)arg1;
- (void)__resolveWithFlags:(int)arg1 resultArray:(id)arg2 handler:(CDUnknownBlockType)arg3;
- (void)blockingResolveUntil:(int)arg1;
- (void)resolve:(CDUnknownBlockType)arg1;
- (id)_thingToResolve;
- (id)initToResolve:(id)arg1 as:(int)arg2;

@end

@interface NSURLRequest : NSObject <NSSecureCoding, NSCopying, NSMutableCopying>
{
    NSURLRequestInternal *_internal;
}

+ (double)defaultTimeoutInterval;
+ (void)setDefaultTimeoutInterval:(double)arg1;
+ (_Bool)supportsSecureCoding;
+ (id)getObjectKeyWithIndex:(long long)arg1;
+ (id)requestWithURL:(id)arg1;
+ (id)requestWithURL:(id)arg1 cachePolicy:(unsigned long long)arg2 timeoutInterval:(double)arg3;
+ (void)setAllowsSpecificHTTPSCertificate:(id)arg1 forHost:(id)arg2;
+ (id)allowsSpecificHTTPSCertificateForHost:(id)arg1;
+ (void)setAllowsAnyHTTPSCertificate:(_Bool)arg1 forHost:(id)arg2;
+ (_Bool)allowsAnyHTTPSCertificateForHost:(id)arg1;
- (id)boundInterfaceIdentifier;
@property(readonly) _Bool allowsCellularAccess;
@property(readonly) unsigned long long networkServiceType;
- (void)_removePropertyForKey:(id)arg1;
- (void)_setProperty:(id)arg1 forKey:(id)arg2;
- (id)_propertyForKey:(id)arg1;
- (_Bool)_URLHasScheme:(id)arg1;
- (id)_copyReplacingURLWithURL:(id)arg1;
- (id)mutableCopyWithZone:(struct _NSZone *)arg1;
- (id)copyWithZone:(struct _NSZone *)arg1;
- (id)description;
- (_Bool)isEqual:(id)arg1;
- (unsigned long long)hash;
- (void)dealloc;
@property(readonly, copy) NSURL *mainDocumentURL;
@property(readonly) double timeoutInterval;
@property(readonly) unsigned long long cachePolicy;
@property(readonly, copy) NSURL *URL;
- (struct _CFURLRequest *)_CFURLRequest;
- (void)encodeWithCoder:(id)arg1;
- (id)initWithCoder:(id)arg1;
- (id)init;
- (id)initWithURL:(id)arg1;
- (id)_initWithCFURLRequest:(struct _CFURLRequest *)arg1;
- (id)initWithURL:(id)arg1 cachePolicy:(unsigned long long)arg2 timeoutInterval:(double)arg3;
- (_Bool)_isSafeRequestForBackgroundDownload;
- (double)_timeWindowDuration;
- (double)_timeWindowDelay;
- (unsigned long long)expectedWorkload;
- (id)contentDispositionEncodingFallbackArray;
@property(readonly) _Bool HTTPShouldUsePipelining;
@property(readonly) _Bool HTTPShouldHandleCookies;
- (id)HTTPUserAgent;
- (id)HTTPReferrer;
- (id)HTTPExtraCookies;
- (id)HTTPContentType;
@property(readonly, retain) NSInputStream *HTTPBodyStream;
@property(readonly, copy) NSData *HTTPBody;
- (id)valueForHTTPHeaderField:(id)arg1;
@property(readonly, copy) NSDictionary *allHTTPHeaderFields;
@property(readonly, copy) NSString *HTTPMethod;

@end

@interface NSMutableURLRequest : NSURLRequest
{
}

- (void)setBoundInterfaceIdentifier:(id)arg1;
@property _Bool allowsCellularAccess;
@property unsigned long long networkServiceType;
- (id)copyWithZone:(struct _NSZone *)arg1;
@property(copy) NSURL *mainDocumentURL;
@property double timeoutInterval;
@property unsigned long long cachePolicy;
@property(copy) NSURL *URL;
- (void)setContentDispositionEncodingFallbackArray:(id)arg1;
- (void)_setTimeWindowDuration:(double)arg1;
- (void)_setTimeWindowDelay:(double)arg1;
- (void)setExpectedWorkload:(unsigned long long)arg1;
@property _Bool HTTPShouldUsePipelining;
- (unsigned long long)requestPriority;
- (void)setRequestPriority:(unsigned long long)arg1;
@property _Bool HTTPShouldHandleCookies;
- (void)setHTTPUserAgent:(id)arg1;
- (void)setHTTPReferrer:(id)arg1;
- (void)setHTTPExtraCookies:(id)arg1;
- (void)setHTTPContentType:(id)arg1;
@property(retain) NSInputStream *HTTPBodyStream;
@property(copy) NSData *HTTPBody;
- (void)addValue:(id)arg1 forHTTPHeaderField:(id)arg2;
- (void)setValue:(id)arg1 forHTTPHeaderField:(id)arg2;
@property(copy) NSDictionary *allHTTPHeaderFields;
@property(copy) NSString *HTTPMethod;

@end

@interface NSNetService : NSObject
{
    id _netService;
    id _delegate;
    id _reserved;
}

+ (id)dataFromTXTRecordDictionary:(id)arg1;
+ (id)dictionaryFromTXTRecordData:(id)arg1;
- (id)TXTRecordData;
- (_Bool)setTXTRecordData:(id)arg1;
- (void)stopMonitoring;
- (void)startMonitoring;
- (id)_monitors;
- (void)resolve;
- (void)resolveWithTimeout:(double)arg1;
- (_Bool)getInputStream:(out id *)arg1 outputStream:(out id *)arg2;
- (_Bool)isEqual:(id)arg1;
- (unsigned long long)hash;
- (id)description;
- (struct __CFNetService *)_internalNetService;
- (void)finalize;
- (void)dealloc;
- (void)_dispatchCallBackWithError:(CDStruct_87dc826d)arg1;
- (void)stop;
- (void)publish;
- (void)publishWithOptions:(unsigned long long)arg1;
- (void)publishWithServer:(unsigned long long)arg1;
- (id)normalizedType;
- (void)_internal_publishWithOptions:(unsigned long long)arg1;
@property(readonly) long long port;
@property(readonly, copy) NSArray *addresses;
@property(readonly, copy) NSString *hostName;
@property(readonly, copy) NSString *name;
@property(readonly, copy) NSString *type;
@property(readonly, copy) NSString *domain;
- (void)removeFromRunLoop:(id)arg1 forMode:(id)arg2;
- (void)scheduleInRunLoop:(id)arg1 forMode:(id)arg2;
- (void)_scheduleInDefaultRunLoopForMode:(id)arg1;
- (void)_setIncludesAWDL:(_Bool)arg1;
- (_Bool)_includesAWDL;
@property _Bool includesPeerToPeer;
@property id <NSNetServiceDelegate> delegate;
- (id)initWithDomain:(id)arg1 type:(id)arg2 name:(id)arg3;
- (id)initWithDomain:(id)arg1 type:(id)arg2 name:(id)arg3 port:(int)arg4;
- (id)initWithCFNetService:(struct __CFNetService *)arg1;

@end

@interface NSNetServiceBrowser : NSObject
{
    id _netServiceBrowser;
    id _delegate;
    void *_reserved;
    _Bool _includesPeerToPeer;
}

@property _Bool includesPeerToPeer; // @synthesize includesPeerToPeer=_includesPeerToPeer;
- (void)finalize;
- (void)dealloc;
- (void)_dispatchCallBack:(void *)arg1 flags:(unsigned long long)arg2 error:(CDStruct_87dc826d)arg3;
- (struct __CFNetServiceBrowser *)_internalNetServiceBrowser;
- (void)stop;
- (void)searchForServicesOfType:(id)arg1 inDomain:(id)arg2;
- (void)_setIncludesAWDL:(_Bool)arg1;
- (_Bool)_includesAWDL;
- (void)searchForRegistrationDomains;
- (void)searchForBrowsableDomains;
- (void)removeFromRunLoop:(id)arg1 forMode:(id)arg2;
- (void)scheduleInRunLoop:(id)arg1 forMode:(id)arg2;
@property id <NSNetServiceBrowserDelegate> delegate;
- (id)init;
- (void)searchForAllDomains;

@end

__attribute__((visibility("hidden")))
@interface NSNetServicesInternal : NSObject
{
    NSMutableArray *_monitors;
    NSObject<OS_tcp_listener> *_listener;
    struct __CFRunLoop *_scheduledRunLoop;
    struct __CFString *_scheduledMode;
}

@property(retain) NSMutableArray *monitors; // @synthesize monitors=_monitors;
- (void)setListener:(id)arg1;
- (id)listener;
- (void)setScheduledRunLoop:(struct __CFRunLoop *)arg1 andMode:(struct __CFString *)arg2;
- (void)copyScheduledRunLoop:(struct __CFRunLoop **)arg1 andMode:(const struct __CFString **)arg2;
- (void)finalize;
- (void)dealloc;

@end

@interface NSURL (NSURLSession_Additions)
- (_Bool)_isSafeDirectoryForDownloads:(int)arg1;
- (_Bool)_isSafeFileForBackgroundUpload:(int)arg1;
@end

@interface NSURLAuthenticationChallenge : NSObject <NSSecureCoding>
{
    NSURLAuthenticationChallengeInternal *_internal;
}

+ (_Bool)supportsSecureCoding;
+ (id)_createAuthenticationChallengeForCFAuthChallenge:(struct _CFURLAuthChallenge *)arg1 sender:(id)arg2;
+ (id)_authenticationChallengeForCFAuthChallenge:(struct _CFURLAuthChallenge *)arg1 sender:(id)arg2;
- (id)initWithCoder:(id)arg1;
- (void)encodeWithCoder:(id)arg1;
@property(readonly, retain) id <NSURLAuthenticationChallengeSender> sender;
@property(readonly, copy) NSURLResponse *failureResponse;
@property(readonly, copy) NSError *error;
@property(readonly) long long previousFailureCount;
@property(readonly, copy) NSURLCredential *proposedCredential;
@property(readonly, copy) NSURLProtectionSpace *protectionSpace;
- (void)dealloc;
- (id)_initWithCFAuthChallenge:(struct _CFURLAuthChallenge *)arg1 sender:(id)arg2;
- (id)initWithAuthenticationChallenge:(id)arg1 sender:(id)arg2;
- (id)initWithProtectionSpace:(id)arg1 proposedCredential:(id)arg2 previousFailureCount:(long long)arg3 failureResponse:(id)arg4 error:(id)arg5 sender:(id)arg6;
- (id)init;
- (struct _CFURLAuthChallenge *)_createCFAuthChallenge;
- (void)setSender:(id)arg1;

@end

__attribute__((visibility("hidden")))
@interface NSURLAuthenticationChallengeInternal : NSObject
{
    NSURLProtectionSpace *space;
    NSURLCredential *proposedCredential;
    long long previousFailureCount;
    NSURLResponse *failureResponse;
    NSError *error;
    id <NSURLAuthenticationChallengeSender> sender;
}

- (void)dealloc;
- (id)initWithProtectionSpace:(id)arg1 proposedCredential:(id)arg2 previousFailureCount:(long long)arg3 failureResponse:(id)arg4 error:(id)arg5 sender:(id)arg6;

@end

@interface NSURLCache : NSObject
{
    NSURLCacheInternal *_internal;
}

+ (void)setSharedURLCache:(id)arg1;
+ (id)sharedURLCache;
- (id)_diskCacheDefaultPath;
- (id)_cacheDirectory;
- (struct _CFURLCache *)_CFURLCache;
- (void)dealloc;
@property(readonly) unsigned long long currentDiskUsage;
@property(readonly) unsigned long long currentMemoryUsage;
@property unsigned long long diskCapacity;
@property unsigned long long memoryCapacity;
- (void)removeCachedResponsesSinceDate:(id)arg1;
- (void)removeAllCachedResponses;
- (void)removeCachedResponseForRequest:(id)arg1;
- (void)storeCachedResponse:(id)arg1 forRequest:(id)arg2;
- (id)cachedResponseForRequest:(id)arg1;
- (void)flushWithCompletion:(CDUnknownBlockType)arg1;
- (id)_initWithMemoryCapacity:(unsigned long long)arg1 diskCapacity:(unsigned long long)arg2 relativePath:(id)arg3;
- (id)initWithMemoryCapacity:(unsigned long long)arg1 diskCapacity:(unsigned long long)arg2 diskPath:(id)arg3;
- (id)_initWithExistingCFURLCache:(struct _CFURLCache *)arg1;
- (id)initWithExistingSharedCFURLCache:(struct _CFURLCache *)arg1;
- (id)init;
- (id)_initWithIdentifier:(id)arg1 memoryCapacity:(long long)arg2 diskCapacity:(long long)arg3 private:(_Bool)arg4;
- (long long)_nscfBridgeURLCacheCurrentDiskUsage;
- (long long)_nscfBridgeURLCacheCurrentMemoryUsage;
- (long long)_nscfBridgeURLCacheMemoryCapacity;
- (void)_nscfBridgeURLCacheRemoveAllCachedResponses;
- (void)_nscfBridgeURLCacheRemoveCachedResponseForRequest:(id)arg1;
- (void)_nscfBridgeURLCacheSetDiskCapacity:(long long)arg1;
- (void)_nscfBridgeURLCacheSetMemoryCapacity:(long long)arg1;
- (long long)_nscfBridgeURLCacheDiskCapacity;
- (void)_nscfBridgeURLCacheStoreCachedResponse:(struct _CFCachedURLResponse *)arg1 forRequest:(struct _CFURLRequest *)arg2;
- (struct _CFCachedURLResponse *)_nscfBridgeURLCacheCopyResponseForRequest:(struct _CFURLRequest *)arg1;
- (void)removeCachedResponseForDataTask:(id)arg1;
- (void)getCachedResponseForDataTask:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (void)storeCachedResponse:(id)arg1 forDataTask:(id)arg2;

@end

__attribute__((visibility("hidden")))
@interface NSURLCacheInternal : NSObject
{
    unsigned long long memoryCapacity;
    unsigned long long diskCapacity;
    NSString *diskPath;
    unsigned long long currentMemoryUsage;
    unsigned long long currentDiskUsage;
    struct _CFURLCache *_cacheRef;
}

- (void)finalize;
- (void)dealloc;

@end

@interface NSURLConnection : NSObject <NSURLAuthenticationChallengeSender>
{
    NSURLConnectionInternal *_internal;
}

+ (void)_setSweeperInterval:(unsigned long long)arg1;
+ (unsigned long long)_sweeperInterval;
+ (_Bool)canHandleRequest:(id)arg1;
+ (void)sendAsynchronousRequest:(id)arg1 queue:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
+ (id)sendSynchronousRequest:(id)arg1 returningResponse:(id *)arg2 error:(id *)arg3;
+ (id)connectionWithRequest:(id)arg1 delegate:(id)arg2;
+ (void)_setMIMETypesWithNoSizeLimit:(id)arg1;
+ (void)_resourceLoadLoop:(id)arg1;
+ (void)_setLoaderThreadPriority:(int)arg1;
+ (struct __CFRunLoop *)resourceLoaderRunLoop;
+ (_Bool)_collectsTimingData;
+ (void)_setCollectsTimingData:(_Bool)arg1;
- (void)_resumeLoading;
- (void)_suspendLoading;
- (id)_cfInternal;
- (id)_dlInternal;
- (_Bool)defersCallbacks;
- (void)setDefersCallbacks:(_Bool)arg1;
- (id)connectionProperties;
- (void)download;
@property(readonly, copy) NSURLRequest *currentRequest;
@property(readonly, copy) NSURLRequest *originalRequest;
- (void)unscheduleFromRunLoop:(id)arg1 forMode:(id)arg2;
- (void)scheduleInRunLoop:(id)arg1 forMode:(id)arg2;
- (void)cancel;
- (void)start;
- (void)setDelegateQueue:(id)arg1;
- (void)dealloc;
@property(readonly, copy) NSString *description;
- (id)initWithRequest:(id)arg1 delegate:(id)arg2;
- (id)initWithRequest:(id)arg1 delegate:(id)arg2 startImmediately:(_Bool)arg3;
- (void)rejectProtectionSpaceAndContinueWithChallenge:(id)arg1;
- (void)performDefaultHandlingForAuthenticationChallenge:(id)arg1;
- (void)cancelAuthenticationChallenge:(id)arg1;
- (void)continueWithoutCredentialForAuthenticationChallenge:(id)arg1;
- (void)useCredential:(id)arg1 forAuthenticationChallenge:(id)arg2;
- (id)_initWithRequest:(id)arg1 delegate:(id)arg2 usesCache:(_Bool)arg3 maxContentLength:(long long)arg4 startImmediately:(_Bool)arg5 connectionProperties:(id)arg6;
- (id)_timingData;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface NSURLConnectionInternal : NSObject <NSURLConnectionRequired, NSURLAuthenticationChallengeSender>
{
    NSURLConnection *_connection;
    NSOperationQueue *_delegateQueue;
    NSURL *_url;
    NSURLRequest *_originalRequest;
    NSURLRequest *_currentRequest;
    id _delegate;
    NSDictionary *_connectionProperties;
    _Bool _connectionActive;
}

- (id)_timingData;
- (void)rejectProtectionSpaceAndContinueWithChallenge:(id)arg1;
- (void)performDefaultHandlingForAuthenticationChallenge:(id)arg1;
- (void)cancelAuthenticationChallenge:(id)arg1;
- (void)continueWithoutCredentialForAuthenticationChallenge:(id)arg1;
- (void)useCredential:(id)arg1 forAuthenticationChallenge:(id)arg2;
- (void)_withConnectionAndDelegate:(CDUnknownBlockType)arg1;
- (void)_withActiveConnectionAndDelegate:(CDUnknownBlockType)arg1;
- (void)_withConnectionAndDelegate:(CDUnknownBlockType)arg1 onlyActive:(_Bool)arg2;
- (void)invokeForDelegate:(CDUnknownBlockType)arg1;
- (void)_withConnectionDisconnectFromConnection;
- (void)_invalidate;
- (_Bool)isConnectionActive;
- (void)setConnectionActive:(_Bool)arg1;
- (void)_setDelegateQueue:(id)arg1;
- (id)currentRequest;
- (id)originalRequest;
- (id)_connectionProperties;
- (void)dealloc;
- (id)initWithInfo:(const struct InternalInit *)arg1;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface NSURLConnectionInternalBackgroundDownload : NSURLConnectionInternal <NSURLConnectionRequired, SSDownloadManagerObserver, SSDownloadHandlerDelegate>
{
    struct __CFRunLoopSource *_source;
    NSMutableArray *_pendingOps;
    NSCountedSet *_runloops;
    SSDownloadHandler *_handler;
    NSAsyncSSDownloadManager *_manager;
    long long _downloadIdent;
    long long _ctLast;
    _Bool _terminated;
    NSTimer *_deferredStartTimer;
}

+ (void)_enableLogging;
+ (id)sharedDownloadManagerForMediaKind:(id)arg1 persistenceIdentifier:(id)arg2;
- (void)rejectProtectionSpaceAndContinueWithChallenge:(id)arg1;
- (void)performDefaultHandlingForAuthenticationChallenge:(id)arg1;
- (void)cancelAuthenticationChallenge:(id)arg1;
- (void)continueWithoutCredentialForAuthenticationChallenge:(id)arg1;
- (void)useCredential:(id)arg1 forAuthenticationChallenge:(id)arg2;
- (void)_updateDownloadState:(id)arg1;
- (long long)_getDownloadIdent;
- (void)_updateClientWithCurrentWrites:(id)arg1;
- (void)downloadHandler:(id)arg1 handleAuthenticationSession:(id)arg2;
- (_Bool)downloadHandler:(id)arg1 pauseSession:(id)arg2;
- (void)downloadHandler:(id)arg1 cancelSession:(id)arg2;
- (void)downloadHandlerDidDisconnect:(id)arg1;
- (void)setDelegateQueue:(id)arg1;
- (void)unscheduleFromRunLoop:(id)arg1 forMode:(id)arg2;
- (void)scheduleInRunLoop:(id)arg1 forMode:(id)arg2;
- (void)_sourcePerform;
- (void)cancel;
- (void)start;
- (void)_createNewDownload;
- (void)setHandlerForDownload:(id)arg1 completionBlock:(CDUnknownBlockType)arg2;
- (void)_managerFailedToStartInTime;
- (void)dealloc;
- (void)_invalidate;
- (void)_sendTerminalDidFinishToDelegate:(id)arg1;
- (void)_sendTerminalErrorToDelegate:(id)arg1;
- (void)_postTerminalInvocation:(id)arg1;
- (void)_preTerminalInvocation:(id)arg1;
- (void)_invokeInvocation:(id)arg1 withConnection:(id)arg2;
- (void)invokeForDelegate:(CDUnknownBlockType)arg1;
@property(readonly, copy) NSString *description;
- (id)initWithInfo:(const struct InternalInit *)arg1;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface NSURLConnectionInternalConnection : NSURLConnectionInternal <NSURLConnectionRequired>
{
    int _cfConnLock;
    struct _CFURLConnection *_cfConn;
    struct _CFURLAuthChallenge *_currCFChallenge;
    NSURLAuthenticationChallenge *_currNSChallenge;
    struct __CFString *_fileName;
    _Bool _shouldSkipCancelOnRelease;
    long long _totalBytes;
    long long _expectedTotalBytes;
}

- (void)rejectProtectionSpaceAndContinueWithChallenge:(id)arg1;
- (void)performDefaultHandlingForAuthenticationChallenge:(id)arg1;
- (void)cancelAuthenticationChallenge:(id)arg1;
- (void)continueWithoutCredentialForAuthenticationChallenge:(id)arg1;
- (void)useCredential:(id)arg1 forAuthenticationChallenge:(id)arg2;
- (void)cleanupChallenges;
- (void)_setShouldSkipCancelOnRelease:(_Bool)arg1;
- (void)_resumeLoading;
- (void)_suspendLoading;
- (void)unscheduleFromRunLoop:(id)arg1 forMode:(id)arg2;
- (void)scheduleInRunLoop:(id)arg1 forMode:(id)arg2;
- (void)cancel;
- (void)start;
- (void)invokeForDelegate:(CDUnknownBlockType)arg1;
- (void)_invalidate;
- (void)_setDelegateQueue:(id)arg1;
- (void)dealloc;
- (id)_timingData;
- (struct _CFURLConnection *)_retainCFURLConnection;
- (struct _CFURLConnection *)_atomic_CFURLConnection;
- (struct _CFURLConnection *)_CFURLConnection;
- (id)initWithInfo:(const struct InternalInit *)arg1;
- (void)sendCFChallenge:(struct _CFURLAuthChallenge *)arg1 toSelector:(SEL)arg2;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

@interface NSURLCredential : NSObject <NSSecureCoding, NSCopying>
{
    NSURLCredentialInternal *_internal;
}

+ (_Bool)supportsSecureCoding;
+ (id)credentialForTrust:(struct __SecTrust *)arg1;
+ (id)credentialWithIdentity:(struct __SecIdentity *)arg1 certificates:(id)arg2 persistence:(unsigned long long)arg3;
+ (id)credentialWithUser:(id)arg1 password:(id)arg2 persistence:(unsigned long long)arg3;
- (void)_removeSWCACreatorAttribute;
- (_Bool)_hasSWCACreatorAttribute;
- (id)initWithCoder:(id)arg1;
- (void)encodeWithCoder:(id)arg1;
- (id)initWithTrust:(struct __SecTrust *)arg1;
- (id)certificates;
- (struct __SecIdentity *)identity;
- (_Bool)isEqual:(id)arg1;
- (unsigned long long)hash;
- (id)description;
- (id)copyWithZone:(struct _NSZone *)arg1;
@property(readonly) unsigned long long persistence;
- (_Bool)hasPassword;
- (id)password;
- (id)user;
- (struct _CFURLCredential *)_CFURLCredential;
- (struct _CFURLCredential *)_cfurlcredential;
- (void)dealloc;
- (id)initWithIdentity:(struct __SecIdentity *)arg1 certificates:(id)arg2 persistence:(unsigned long long)arg3;
- (id)_initWithCFURLCredential:(struct _CFURLCredential *)arg1;
- (id)initWithUser:(id)arg1 password:(id)arg2 persistence:(unsigned long long)arg3;

@end

@interface NSURLCredentialStorage : NSObject
{
    NSURLCredentialStorageInternal *_internal;
}

+ (id)sharedCredentialStorage;
- (void)setDefaultCredential:(id)arg1 forProtectionSpace:(id)arg2 task:(id)arg3;
- (void)getDefaultCredentialForProtectionSpace:(id)arg1 task:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (void)removeCredential:(id)arg1 forProtectionSpace:(id)arg2 options:(id)arg3 task:(id)arg4;
- (void)setCredential:(id)arg1 forProtectionSpace:(id)arg2 task:(id)arg3;
- (void)getCredentialsForProtectionSpace:(id)arg1 task:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (void)setDefaultCredential:(id)arg1 forProtectionSpace:(id)arg2;
- (id)defaultCredentialForProtectionSpace:(id)arg1;
- (void)removeCredential:(id)arg1 forProtectionSpace:(id)arg2 options:(id)arg3;
- (void)removeCredential:(id)arg1 forProtectionSpace:(id)arg2;
- (void)setCredential:(id)arg1 forProtectionSpace:(id)arg2;
@property(readonly, copy) NSDictionary *allCredentials;
- (id)credentialsForProtectionSpace:(id)arg1;
- (struct _CFURLCredentialStorage *)_CFURLCredentialStorage;
- (id)_initWithCFURLCredentialStorage:(struct _CFURLCredentialStorage *)arg1;
- (id)init;
- (void)dealloc;
- (id)_initWithIdentifier:(id)arg1 private:(_Bool)arg2;

@end

@interface NSURLDownload : NSObject <NSURLAuthenticationChallengeSender>
{
    NSURLDownloadInternal *_internal;
}

+ (_Bool)_isEncodingMIMETypeResumable:(id)arg1;
+ (_Bool)canResumeDownloadDecodedWithEncodingMIMEType:(id)arg1;
+ (id)_downloadWithRequest:(id)arg1 delegate:(id)arg2 directory:(id)arg3;
+ (id)_downloadWithLoadingCFURLConnection:(struct _CFURLConnection *)arg1 request:(struct _CFURLRequest *)arg2 response:(struct _CFURLResponse *)arg3 delegate:(id)arg4 proxy:(id)arg5;
+ (id)_downloadWithLoadingConnection:(id)arg1 request:(id)arg2 response:(id)arg3 delegate:(id)arg4 proxy:(id)arg5;
- (_Bool)sendCanAuthenticateAgainstProtectionSpace:(struct _CFURLProtectionSpace *)arg1;
- (void)sendDidFail:(struct __CFError *)arg1;
- (void)sendDidFinish;
- (void)sendDidCreateDestination:(struct __CFURL *)arg1;
- (void)sendDecideDestinationWithSuggestedObjectName:(struct __CFString *)arg1;
- (_Bool)sendShouldDecodeDataOfMIMEType:(struct __CFString *)arg1;
- (void)sendDidReceiveData:(long long)arg1;
- (void)sendWillResumeWithResponse:(struct _CFURLResponse *)arg1 startingByte:(unsigned long long)arg2;
- (void)sendDidReceiveResponse:(struct _CFURLResponse *)arg1;
- (void)sendDidReceiveChallenge:(struct _CFURLAuthChallenge *)arg1;
- (unsigned char)sendDownloadShouldUseCredentialStorage;
- (struct _CFURLRequest *)sendWillSendRequest:(struct _CFURLRequest *)arg1 redirectResponse:(struct _CFURLResponse *)arg2;
- (void)sendDidStart:(struct _CFURLDownload *)arg1;
- (void)withDelegate:(CDUnknownBlockType)arg1;
- (_Bool)_downloadActive;
- (id)_delegate;
- (void)releaseDelegate;
- (id)_originatingURL;
- (void)_setOriginatingURL:(id)arg1;
- (void)_setDirectoryPath:(id)arg1;
- (void)_setDelegate:(id)arg1;
- (id)_directoryPath;
- (id)url;
- (void)_setDelegateQueue:(id)arg1;
@property _Bool deletesFileUponFailure;
- (_Bool)_deletesFileAfterFailure;
- (void)_setDeletesFileAfterFailure:(_Bool)arg1;
- (void)setDestination:(id)arg1 allowOverwrite:(_Bool)arg2;
@property(readonly, copy) NSURLRequest *request;
- (void)cancel;
- (void)dealloc;
@property(readonly, copy) NSData *resumeData;
- (id)_resumeInformation;
@property(readonly, copy) NSString *description;
- (id)initWithResumeData:(id)arg1 delegate:(id)arg2 path:(id)arg3;
- (id)_initWithResumeInformation:(id)arg1 delegate:(id)arg2 path:(id)arg3;
- (id)_initWithRequest:(id)arg1 delegate:(id)arg2 directory:(id)arg3;
- (id)_initWithLoadingCFURLConnection:(struct _CFURLConnection *)arg1 request:(struct _CFURLRequest *)arg2 response:(struct _CFURLResponse *)arg3 delegate:(id)arg4 proxy:(id)arg5;
- (id)_initWithLoadingConnection:(id)arg1 request:(id)arg2 response:(id)arg3 delegate:(id)arg4 proxy:(id)arg5;
- (id)initWithRequest:(id)arg1 delegate:(id)arg2;
- (id)init;
- (void)cancelAuthenticationChallenge:(id)arg1;
- (void)continueWithoutCredentialForAuthenticationChallenge:(id)arg1;
- (void)useCredential:(id)arg1 forAuthenticationChallenge:(id)arg2;
- (void)cleanupChallenges;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface NSURLDownloadInternal : NSObject
{
    struct _CFURLDownload *cfDownload;
    struct _CFURLAuthChallenge *currCFChallenge;
    NSURLAuthenticationChallenge *currNSChallenge;
    id delegate;
    _Bool downloadActive;
    NSOperationQueue *_targetQueue;
}

- (void)dealloc;

@end

@interface NSURLProtectionSpace : NSObject <NSSecureCoding, NSCopying>
{
    NSURLProtectionSpaceInternal *_internal;
}

+ (_Bool)supportsSecureCoding;
- (id)initWithCoder:(id)arg1;
- (void)encodeWithCoder:(id)arg1;
- (struct _CFURLProtectionSpace *)_CFURLProtectionSpace;
- (struct _CFURLProtectionSpace *)_cfurlprtotectionspace;
@property(readonly, copy) NSString *protocol;
- (struct __SecTrust *)serverTrust;
- (id)distinguishedNames;
@property(readonly, copy) NSString *authenticationMethod;
- (_Bool)isEqual:(id)arg1;
- (unsigned long long)hash;
- (id)copyWithZone:(struct _NSZone *)arg1;
@property(readonly, copy) NSString *proxyType;
@property(readonly) long long port;
@property(readonly, copy) NSString *host;
@property(readonly) _Bool isProxy;
@property(readonly) _Bool receivesCredentialSecurely;
@property(readonly, copy) NSString *realm;
- (id)description;
- (void)dealloc;
- (id)init;
- (id)_initWithCFURLProtectionSpace:(struct _CFURLProtectionSpace *)arg1;
- (id)initWithProxyHost:(id)arg1 port:(long long)arg2 type:(id)arg3 realm:(id)arg4 authenticationMethod:(id)arg5;
- (id)initWithHost:(id)arg1 port:(long long)arg2 protocol:(id)arg3 realm:(id)arg4 authenticationMethod:(id)arg5;
- (id)_internalInit;

@end

__attribute__((visibility("hidden")))
@interface NSURLProtocolInternal : NSObject
{
    id <NSURLProtocolClient> client;
    NSURLRequest *request;
    NSCachedURLResponse *cachedResponse;
    NSLock *mutex;
}

- (void)dealloc;
- (id)init;

@end

__attribute__((visibility("hidden")))
@interface NSURLRequestInternal : NSObject
{
    struct _CFURLRequest *request;
}

- (void)dealloc;

@end

__attribute__((visibility("hidden")))
@interface NSURLResponseInternal : NSObject
{
    struct _CFURLResponse *response;
}

- (void)dealloc;
- (id)initWithURLResponse:(struct _CFURLResponse *)arg1;

@end

@interface NSURLSession : NSObject
{
    _Bool _invalid;
    _Bool __isSharedSession;
    NSOperationQueue *_delegateQueue;
    id <NSURLSessionDelegate> _delegate;
    NSString *_sessionDescription;
    NSURLSessionConfiguration *__local_immutable_configuration;
    NSObject<OS_dispatch_queue> *_workQueue;
    NSOperationQueue *_realDelegateQueue;
    CDUnknownBlockType __connBlock;
}

+ (id)sessionWithConfiguration:(id)arg1 delegate:(id)arg2 delegateQueue:(id)arg3;
+ (id)sessionWithConfiguration:(id)arg1;
+ (void)_obliterateAllBackgroundSessionsWithCompletionHandler:(CDUnknownBlockType)arg1;
+ (void)_getActiveSessionIdentifiersWithCompletionHandler:(CDUnknownBlockType)arg1;
+ (id)sharedSession;
+ (void)_releaseProcessAssertionForSessionIdentifier:(id)arg1;
+ (void)_sendPendingCallbacksForSessionIdentifier:(id)arg1;
@property(copy) CDUnknownBlockType _connBlock; // @synthesize _connBlock=__connBlock;
@property _Bool _isSharedSession; // @synthesize _isSharedSession=__isSharedSession;
@property(retain) NSOperationQueue *realDelegateQueue; // @synthesize realDelegateQueue=_realDelegateQueue;
@property _Bool invalid; // @synthesize invalid=_invalid;
@property NSObject<OS_dispatch_queue> *workQueue; // @synthesize workQueue=_workQueue;
@property(retain) NSURLSessionConfiguration *_local_immutable_configuration; // @synthesize _local_immutable_configuration=__local_immutable_configuration;
@property(copy) NSString *sessionDescription; // @synthesize sessionDescription=_sessionDescription;
@property(retain) id <NSURLSessionDelegate> delegate; // @synthesize delegate=_delegate;
@property(retain) NSOperationQueue *delegateQueue; // @synthesize delegateQueue=_delegateQueue;
- (void)delegate_streamTask:(id)arg1 didCreateInputStream:(id)arg2 outputStream:(id)arg3 completionHandler:(CDUnknownBlockType)arg4;
- (_Bool)can_delegate_streamTask_didCreateInputStreamoutputStream;
- (void)delegate_dataTask:(id)arg1 didBecomeStreamTask:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (_Bool)can_delegate_dataTask_didBecomeStreamTask;
- (void)delegate_AVAssetDownloadTask:(id)arg1 didReceiveDownloadToken:(unsigned long long)arg2;
- (_Bool)can_delegate_AVAssetDownloadTask_didReceiveDownloadToken;
- (void)delegate_AVAssetDownloadTask:(id)arg1 didWriteData:(long long)arg2 totalBytesWritten:(long long)arg3 totalBytesExpectedToWrite:(long long)arg4;
- (_Bool)can_delegate_AVAssetDownloadTask_didWriteData;
- (void)delegate_didFinishEventsForBackgroundURLSession;
- (_Bool)can_delegate_didFinishEventsForBackgroundURLSession;
- (id)delegate_downloadTaskNeedsDownloadDirectory:(id)arg1;
- (_Bool)can_delegate_downloadTaskNeedsDownloadDirectory;
- (void)delegate_downloadTask:(id)arg1 didReceiveResponse:(id)arg2;
- (_Bool)can_delegate_downloadTask_didReceiveResponse;
- (void)delegate_downloadTask:(id)arg1 didResumeAtOffset:(long long)arg2 expectedTotalBytes:(long long)arg3;
- (_Bool)can_delegate_downloadTask_didResumeAtOffset;
- (void)delegate_downloadTask:(id)arg1 didWriteData:(long long)arg2 totalBytesWritten:(long long)arg3 totalBytesExpectedToWrite:(long long)arg4 completionHandler:(CDUnknownBlockType)arg5;
- (_Bool)can_delegate_downloadTask_didWriteData;
- (void)delegate_downloadTask:(id)arg1 didFinishDownloadingToURL:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (_Bool)can_delegate_downloadTask_didFinishDownloadingToURL;
- (void)delegate_willRetryBackgroundDataTask:(id)arg1 withError:(id)arg2;
- (_Bool)can_delegate_willRetryBackgroundDataTask;
- (void)delegate_dataTask:(id)arg1 willCacheResponse:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (_Bool)can_delegate_dataTask_willCacheResponse;
- (void)delegate_dataTask:(id)arg1 didReceiveData:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (_Bool)can_delegate_dataTask_didReceiveData;
- (void)delegate_dataTask:(id)arg1 didBecomeDownloadTask:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (_Bool)can_delegate_dataTask_didBecomeDownloadTask;
- (void)delegate_dataTask:(id)arg1 didReceiveResponse:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (_Bool)can_delegate_dataTask_didReceiveResponse;
- (void)delegate_task:(id)arg1 conditionalRequirementsChanged:(_Bool)arg2;
- (_Bool)can_delegate_task_conditionalRequirementsChanged;
- (void)delegate_task_isWaitingForConnection:(id)arg1;
- (_Bool)can_delegate_task_isWaitingForConnection;
- (void)delegate_task:(id)arg1 _willSendRequestForEstablishedConnection:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (_Bool)can_delegate_task_willSendRequestForEstablishedConnection;
- (void)delegate_task:(id)arg1 didCompleteWithError:(id)arg2;
- (_Bool)can_delegate_task_actually_didCompleteWithError;
- (_Bool)can_delegate_task_didCompleteWithError;
- (void)delegate_task:(id)arg1 didSendBodyData:(long long)arg2 totalBytesSent:(long long)arg3 totalBytesExpectedToSend:(long long)arg4;
- (_Bool)can_delegate_task_didSendBodyData;
- (void)delegate_task:(id)arg1 needNewBodyStream:(CDUnknownBlockType)arg2;
- (_Bool)can_delegate_task_needNewBodyStream;
- (void)delegate_task:(id)arg1 didReceiveChallenge:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (_Bool)can_delegate_task_didReceiveChallenge;
- (void)delegate_task:(id)arg1 willPerformHTTPRedirection:(id)arg2 newRequest:(id)arg3 completionHandler:(CDUnknownBlockType)arg4;
- (_Bool)can_delegate_task_willPerformHTTPRedirection;
- (int)delegate_openFileAtPath:(id)arg1 mode:(int)arg2;
- (_Bool)can_delegate_openFileAtPath;
- (void)delegate_didReceiveChallenge:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (_Bool)can_delegate_didReceiveChallenge;
- (void)addDelegateBlock:(CDUnknownBlockType)arg1;
- (id)streamTaskForHost:(id)arg1 port:(long long)arg2 tls:(_Bool)arg3 completionHandler:(CDUnknownBlockType)arg4;
- (id)streamTaskForHost:(id)arg1 port:(long long)arg2 tls:(_Bool)arg3;
- (id)_AVAssetDownloadTaskWithURL:(id)arg1 destinationURL:(id)arg2 options:(id)arg3;
- (id)downloadTaskWithResumeData:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (id)downloadTaskWithURL:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (id)downloadTaskWithRequest:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (id)downloadTaskWithResumeData:(id)arg1;
- (id)downloadTaskWithURL:(id)arg1;
- (id)downloadTaskWithRequest:(id)arg1;
- (id)_downloadTaskWithRequest:(id)arg1 downloadFilePath:(id)arg2;
- (id)uploadTaskWithRequest:(id)arg1 fromData:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (id)uploadTaskWithRequest:(id)arg1 fromFile:(id)arg2 completionHandler:(CDUnknownBlockType)arg3;
- (id)uploadTaskWithStreamedRequest:(id)arg1;
- (id)uploadTaskWithRequest:(id)arg1 fromData:(id)arg2;
- (id)uploadTaskWithRequest:(id)arg1 fromFile:(id)arg2;
- (id)dataTaskWithRequest:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (id)dataTaskWithURL:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (id)dataTaskWithURL:(id)arg1;
- (id)dataTaskWithRequest:(id)arg1;
- (id)dataTaskWithHTTPGetRequest:(id)arg1;
- (id)dataTaskWithHTTPGetRequest:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (void)getTasksWithCompletionHandler:(CDUnknownBlockType)arg1;
- (void)flushWithCompletionHandler:(CDUnknownBlockType)arg1;
- (void)resetWithCompletionHandler:(CDUnknownBlockType)arg1;
- (void)finishTasksAndInvalidate;
- (void)invalidateAndCancel;
- (_Bool)isBackgroundSession;
@property(readonly, copy) NSURLSessionConfiguration *configuration;
- (void)finalizeDelegateWithError:(id)arg1;
- (id)_copyConfiguration;
- (void)dealloc;
- (id)copyWithZone:(struct _NSZone *)arg1;
- (id)initWithConfiguration:(id)arg1 delegate:(id)arg2 delegateQueue:(id)arg3;

@end

@interface NSURLSessionTask : NSObject <NSCopying>
{
    _Bool __shouldSkipPreferredClientCertificateLookup;
    _Bool __shouldPipelineHTTP;
    _Bool __shouldUsePipelineHeuristics;
    _Bool __shouldSkipPipelineProbe;
    _Bool __shouldHandleCookies;
    _Bool __preventsIdleSystemSleep;
    _Bool __allowsCellular;
    _Bool __prohibitAuthUI;
    _Bool __strictContentLength;
    _Bool __disallowCellular;
    _Bool __connectionIsCellular;
    float __priorityHint;
    int __cachePolicy;
    int __cookieAcceptPolicy;
    int __networkServiceType;
    unsigned int __powerAssertion;
    unsigned long long _taskIdentifier;
    NSURLRequest *_originalRequest;
    NSURLResponse *_response;
    long long _countOfBytesReceived;
    long long _countOfBytesSent;
    long long _countOfBytesExpectedToSend;
    long long _countOfBytesExpectedToReceive;
    NSString *_taskDescription;
    long long _state;
    NSError *_error;
    NSURL *__ledBellyFallbackURL;
    struct _CFURLRequest *__currentCFURLRequest;
    double _startTime;
    NSURLSession *_session;
    NSObject<OS_dispatch_queue> *_workQueue;
    NSString *__ledBellyServiceIdentifier;
    long long __priorityValue;
    struct __PerformanceTiming *__performanceTiming;
    NSDictionary *__backgroundTaskTimingData;
    NSDictionary *__legacySocketStreamProperties;
    struct _CFHSTSPolicy *__cfHSTS;
    struct _CFURLCache *__cfCache;
    struct _CFURLCredentialStorage *__cfCreds;
    struct OpaqueCFHTTPCookieStorage *__cfCookies;
    double __timeoutInterval;
    NSDictionary *__proxySettings;
    NSDictionary *__sslSettings;
    NSDictionary *__additionalHeaders;
    NSArray *__contentDispositionFallbackArray;
    NSValue *__connectionPropertyDuet;
    long long __suspensionThreshhold;
    NSString *__boundInterfaceIdentifier;
    unsigned long long __allowedProtocolTypes;
    long long __requestPriority;
    long long __expectedWorkload;
    double __timeWindowDelay;
    double __timeWindowDuration;
    NSString *__uniqueIdentifier;
    id __protocolForTask;
}

+ (_Bool)supportsSecureCoding;
+ (id)taskForWrappedRequest:(id)arg1;
@property(nonatomic) id _protocolForTask; // @synthesize _protocolForTask=__protocolForTask;
@property(setter=_setConnectionIsCellular:) _Bool _connectionIsCellular; // @synthesize _connectionIsCellular=__connectionIsCellular;
@property unsigned int _powerAssertion; // @synthesize _powerAssertion=__powerAssertion;
@property(copy) NSString *_uniqueIdentifier; // @synthesize _uniqueIdentifier=__uniqueIdentifier;
@property double _timeWindowDuration; // @synthesize _timeWindowDuration=__timeWindowDuration;
@property double _timeWindowDelay; // @synthesize _timeWindowDelay=__timeWindowDelay;
@property long long _expectedWorkload; // @synthesize _expectedWorkload=__expectedWorkload;
@property long long _requestPriority; // @synthesize _requestPriority=__requestPriority;
@property unsigned long long _allowedProtocolTypes; // @synthesize _allowedProtocolTypes=__allowedProtocolTypes;
@property _Bool _disallowCellular; // @synthesize _disallowCellular=__disallowCellular;
@property(retain) NSString *_boundInterfaceIdentifier; // @synthesize _boundInterfaceIdentifier=__boundInterfaceIdentifier;
@property long long _suspensionThreshhold; // @synthesize _suspensionThreshhold=__suspensionThreshhold;
@property(copy) NSValue *_connectionPropertyDuet; // @synthesize _connectionPropertyDuet=__connectionPropertyDuet;
@property _Bool _strictContentLength; // @synthesize _strictContentLength=__strictContentLength;
@property _Bool _prohibitAuthUI; // @synthesize _prohibitAuthUI=__prohibitAuthUI;
@property int _networkServiceType; // @synthesize _networkServiceType=__networkServiceType;
@property _Bool _allowsCellular; // @synthesize _allowsCellular=__allowsCellular;
@property(retain) NSArray *_contentDispositionFallbackArray; // @synthesize _contentDispositionFallbackArray=__contentDispositionFallbackArray;
@property _Bool _preventsIdleSystemSleep; // @synthesize _preventsIdleSystemSleep=__preventsIdleSystemSleep;
@property(retain) NSDictionary *_additionalHeaders; // @synthesize _additionalHeaders=__additionalHeaders;
@property int _cookieAcceptPolicy; // @synthesize _cookieAcceptPolicy=__cookieAcceptPolicy;
@property _Bool _shouldHandleCookies; // @synthesize _shouldHandleCookies=__shouldHandleCookies;
@property _Bool _shouldSkipPipelineProbe; // @synthesize _shouldSkipPipelineProbe=__shouldSkipPipelineProbe;
@property _Bool _shouldUsePipelineHeuristics; // @synthesize _shouldUsePipelineHeuristics=__shouldUsePipelineHeuristics;
@property _Bool _shouldPipelineHTTP; // @synthesize _shouldPipelineHTTP=__shouldPipelineHTTP;
@property(retain) NSDictionary *_sslSettings; // @synthesize _sslSettings=__sslSettings;
@property(retain) NSDictionary *_proxySettings; // @synthesize _proxySettings=__proxySettings;
@property double _timeoutInterval; // @synthesize _timeoutInterval=__timeoutInterval;
@property int _cachePolicy; // @synthesize _cachePolicy=__cachePolicy;
@property(retain) struct OpaqueCFHTTPCookieStorage *_cfCookies; // @synthesize _cfCookies=__cfCookies;
@property(retain) struct _CFURLCredentialStorage *_cfCreds; // @synthesize _cfCreds=__cfCreds;
@property(retain) struct _CFURLCache *_cfCache; // @synthesize _cfCache=__cfCache;
@property(retain) struct _CFHSTSPolicy *_cfHSTS; // @synthesize _cfHSTS=__cfHSTS;
@property(retain) NSDictionary *_legacySocketStreamProperties; // @synthesize _legacySocketStreamProperties=__legacySocketStreamProperties;
@property _Bool _shouldSkipPreferredClientCertificateLookup; // @synthesize _shouldSkipPreferredClientCertificateLookup=__shouldSkipPreferredClientCertificateLookup;
@property(copy, nonatomic) NSDictionary *_backgroundTaskTimingData; // @synthesize _backgroundTaskTimingData=__backgroundTaskTimingData;
@property(nonatomic) struct __PerformanceTiming *_performanceTiming; // @synthesize _performanceTiming=__performanceTiming;
@property long long _priorityValue; // @synthesize _priorityValue=__priorityValue;
@property float _priorityHint; // @synthesize _priorityHint=__priorityHint;
@property(copy) NSString *_ledBellyServiceIdentifier; // @synthesize _ledBellyServiceIdentifier=__ledBellyServiceIdentifier;
@property NSObject<OS_dispatch_queue> *workQueue; // @synthesize workQueue=_workQueue;
@property(retain) NSURLSession *session; // @synthesize session=_session;
@property double startTime; // @synthesize startTime=_startTime;
@property(retain) struct _CFURLRequest *_currentCFURLRequest; // @synthesize _currentCFURLRequest=__currentCFURLRequest;
@property(copy) NSURL *_ledBellyFallbackURL; // @synthesize _ledBellyFallbackURL=__ledBellyFallbackURL;
@property(copy) NSError *error; // @synthesize error=_error;
@property long long state; // @synthesize state=_state;
@property(copy) NSString *taskDescription; // @synthesize taskDescription=_taskDescription;
@property long long countOfBytesExpectedToReceive; // @synthesize countOfBytesExpectedToReceive=_countOfBytesExpectedToReceive;
@property long long countOfBytesExpectedToSend; // @synthesize countOfBytesExpectedToSend=_countOfBytesExpectedToSend;
@property long long countOfBytesSent; // @synthesize countOfBytesSent=_countOfBytesSent;
@property long long countOfBytesReceived; // @synthesize countOfBytesReceived=_countOfBytesReceived;
@property(copy) NSURLResponse *response; // @synthesize response=_response;
@property(copy) NSURLRequest *originalRequest; // @synthesize originalRequest=_originalRequest;
@property unsigned long long taskIdentifier; // @synthesize taskIdentifier=_taskIdentifier;
@property(readonly, copy) NSURLRequest *currentRequest;
@property(readonly, retain) NSURL *originalRequest_mainDocumentURL;
@property(readonly, retain) NSURL *currentRequest_URL;
- (struct __CFHTTPMessage *)_copyHTTPMessage;
- (void)cleanupAndBreakCycles;
- (_Bool)shouldHandleCookiesAndSchemeIsAppropriate;
- (void)_setExplicitCookieStorage:(struct OpaqueCFHTTPCookieStorage *)arg1;
- (void)_setExplicitStorageSession:(struct __CFURLStorageSession *)arg1;
- (void)_setSocketProperties:(struct __CFDictionary *)arg1 connectionProperties:(struct __CFDictionary *)arg2;
- (const struct XCredentialStorage *)_createXCredentialStorage;
- (const struct XCookieStorage *)_createXCookieStorage;
- (const struct XURLCache *)_createXURLCache;
- (struct _CFHSTSPolicy *)_copyHSTSPolicy;
- (void)_onqueue_releasePowerAsssertion;
- (void)_releasePreventIdleSleepAssertionIfAppropriate;
- (void)_takePreventIdleSleepAssertionIfAppropriate;
- (id)_timingData;
- (void)_initializeTimingDataWithSessionConfiguration:(id)arg1;
- (struct __CFDictionary *)_copySocketStreamProperties;
- (struct __CFDictionary *)_copySocketStreamProperties0;
- (void)adjustConditionalConnectionProperties:(struct __CFDictionary *)arg1;
- (void)updateCurrentRequest:(id)arg1;
- (struct _CFURLRequest *)_copyOriginalCFURLRequest;
- (struct _CFURLRequest *)_copyCurrentCFURLRequest;
- (id)copyWithZone:(struct _NSZone *)arg1;
@property long long _priority;
- (void)_onqueue_adjustPriorityHint:(float)arg1;
@property float priority;
- (void)resume;
- (void)suspend;
- (void)cancel;
- (id)description;
- (void)dealloc;
- (id)initWithTask:(id)arg1;
- (id)initWithOriginalRequest:(id)arg1 updatedRequest:(id)arg2 ident:(unsigned long long)arg3 session:(id)arg4;

@end

__attribute__((visibility("hidden")))
@interface NSURLSessionAVAssetDownloadTask : NSURLSessionTask
{
    unsigned long long _AVAssetDownloadToken;
    NSURL *_URL;
    NSURL *_destinationURL;
}

@property(readonly, copy) NSURL *destinationURL; // @synthesize destinationURL=_destinationURL;
@property(readonly, copy) NSURL *URL; // @synthesize URL=_URL;
@property(readonly) unsigned long long AVAssetDownloadToken; // @synthesize AVAssetDownloadToken=_AVAssetDownloadToken;

@end

@interface NSURLSessionConfiguration : NSObject <NSSecureCoding, NSCopying>
{
    _Bool _allowsCellularAccess;
    _Bool _discretionary;
    _Bool _sessionSendsLaunchEvents;
    _Bool _HTTPShouldUsePipelining;
    _Bool _HTTPShouldSetCookies;
    _Bool __requiresPowerPluggedIn;
    _Bool __allowsExpensiveAccess;
    _Bool __allowsPowerNapScheduling;
    _Bool __preventsIdleSleepOnceConnected;
    _Bool __sessionSendsLaunchOnDemandEvents;
    _Bool __collectsTimingData;
    _Bool __shouldSkipPreferredClientCertificateLookup;
    _Bool __allowsRetryForBackgroundDataTasks;
    _Bool __respectsAllowsCellularAccessForDiscretionaryTasks;
    _Bool __infersDiscretionaryFromOriginatingClient;
    _Bool _backgroundSession;
    _Bool __phskip_credStorageSet;
    _Bool __phskip_urlCacheSet;
    _Bool __phskip_cookieStorageSet;
    _Bool __phskip_hstsStorageSet;
    _Bool _skip_download_unlink;
    _Bool __requiresClientToOpenFiles;
    _Bool __forcesNewConnections;
    _Bool __supportsAVAssetDownloads;
    _Bool __proxySession;
    _Bool __disallowsSPDY;
    _Bool __preventsIdleSleep;
    _Bool __usePipeliningHeuristics;
    int _TLSMinimumSupportedProtocol;
    int _TLSMaximumSupportedProtocol;
    NSString *_identifier;
    unsigned long long _requestCachePolicy;
    double _timeoutIntervalForRequest;
    double _timeoutIntervalForResource;
    unsigned long long _networkServiceType;
    NSString *_sharedContainerIdentifier;
    NSDictionary *_connectionProxyDictionary;
    unsigned long long _HTTPCookieAcceptPolicy;
    NSDictionary *_HTTPAdditionalHeaders;
    long long _HTTPMaximumConnectionsPerHost;
    NSArray *_protocolClasses;
    NSURL *__directoryForDownloadedFiles;
    NSString *__sourceApplicationBundleIdentifier;
    NSString *__sourceApplicationSecondaryIdentifier;
    unsigned long long __TCPAdaptiveReadTimeout;
    unsigned long long __TCPAdaptiveWriteTimeout;
    NSString *__ledBellyServiceIdentifier;
    double __connectionCachePurgeTimeout;
    double __connectionCacheCellPurgeTimeout;
    NSString *__connectionPoolName;
    NSString *_disposition;
    NSURLCredentialStorage *__phskip_credStorage;
    NSURLCache *__phskip_urlCache;
    NSHTTPCookieStorage *__phskip_cookieStorage;
    struct _CFHSTSPolicy *__phskip_hstsStorage;
    long long _pipeliningHighWatermark;
    long long _pipeliningLowWatermark;
    long long _numPriorityLevels;
    long long _numFastLanes;
    long long _minimumFastLanePriority;
    NSString *__tcpConnectionPoolName;
    NSDictionary *__socketStreamProperties;
    NSArray *__contentDispHeadEncFallback;
}

+ (_Bool)supportsSecureCoding;
+ (id)backgroundSessionConfiguration:(id)arg1;
+ (id)_proxySessionConfigurationWithIdentifier:(id)arg1;
+ (id)_AVBackgroundSessionConfigurationWithIdentifier:(id)arg1;
+ (id)backgroundSessionConfigurationWithIdentifier:(id)arg1;
+ (id)ephemeralSessionConfiguration;
+ (id)sessionConfigurationForSharedSession;
+ (id)defaultSessionConfiguration;
+ (id)_defaultProtocolClasses;
@property(copy) NSArray *_contentDispHeadEncFallback; // @synthesize _contentDispHeadEncFallback=__contentDispHeadEncFallback;
@property _Bool _usePipeliningHeuristics; // @synthesize _usePipeliningHeuristics=__usePipeliningHeuristics;
@property _Bool _preventsIdleSleep; // @synthesize _preventsIdleSleep=__preventsIdleSleep;
@property _Bool _disallowsSPDY; // @synthesize _disallowsSPDY=__disallowsSPDY;
@property(getter=_isProxySession) _Bool _proxySession; // @synthesize _proxySession=__proxySession;
@property _Bool _supportsAVAssetDownloads; // @synthesize _supportsAVAssetDownloads=__supportsAVAssetDownloads;
@property(copy) NSDictionary *_socketStreamProperties; // @synthesize _socketStreamProperties=__socketStreamProperties;
@property _Bool _forcesNewConnections; // @synthesize _forcesNewConnections=__forcesNewConnections;
@property(copy) NSString *_tcpConnectionPoolName; // @synthesize _tcpConnectionPoolName=__tcpConnectionPoolName;
@property _Bool _requiresClientToOpenFiles; // @synthesize _requiresClientToOpenFiles=__requiresClientToOpenFiles;
@property _Bool skip_download_unlink; // @synthesize skip_download_unlink=_skip_download_unlink;
@property long long minimumFastLanePriority; // @synthesize minimumFastLanePriority=_minimumFastLanePriority;
@property long long numFastLanes; // @synthesize numFastLanes=_numFastLanes;
@property long long numPriorityLevels; // @synthesize numPriorityLevels=_numPriorityLevels;
@property long long pipeliningLowWatermark; // @synthesize pipeliningLowWatermark=_pipeliningLowWatermark;
@property long long pipeliningHighWatermark; // @synthesize pipeliningHighWatermark=_pipeliningHighWatermark;
@property _Bool _phskip_hstsStorageSet; // @synthesize _phskip_hstsStorageSet=__phskip_hstsStorageSet;
@property(retain) struct _CFHSTSPolicy *_phskip_hstsStorage; // @synthesize _phskip_hstsStorage=__phskip_hstsStorage;
@property _Bool _phskip_cookieStorageSet; // @synthesize _phskip_cookieStorageSet=__phskip_cookieStorageSet;
@property(retain) NSHTTPCookieStorage *_phskip_cookieStorage; // @synthesize _phskip_cookieStorage=__phskip_cookieStorage;
@property _Bool _phskip_urlCacheSet; // @synthesize _phskip_urlCacheSet=__phskip_urlCacheSet;
@property(retain) NSURLCache *_phskip_urlCache; // @synthesize _phskip_urlCache=__phskip_urlCache;
@property _Bool _phskip_credStorageSet; // @synthesize _phskip_credStorageSet=__phskip_credStorageSet;
@property(retain) NSURLCredentialStorage *_phskip_credStorage; // @synthesize _phskip_credStorage=__phskip_credStorage;
@property NSString *disposition; // @synthesize disposition=_disposition;
@property(getter=isBackgroundSession) _Bool backgroundSession; // @synthesize backgroundSession=_backgroundSession;
@property(copy) NSString *_connectionPoolName; // @synthesize _connectionPoolName=__connectionPoolName;
@property _Bool _infersDiscretionaryFromOriginatingClient; // @synthesize _infersDiscretionaryFromOriginatingClient=__infersDiscretionaryFromOriginatingClient;
@property _Bool _respectsAllowsCellularAccessForDiscretionaryTasks; // @synthesize _respectsAllowsCellularAccessForDiscretionaryTasks=__respectsAllowsCellularAccessForDiscretionaryTasks;
@property _Bool _allowsRetryForBackgroundDataTasks; // @synthesize _allowsRetryForBackgroundDataTasks=__allowsRetryForBackgroundDataTasks;
@property double _connectionCacheCellPurgeTimeout; // @synthesize _connectionCacheCellPurgeTimeout=__connectionCacheCellPurgeTimeout;
@property double _connectionCachePurgeTimeout; // @synthesize _connectionCachePurgeTimeout=__connectionCachePurgeTimeout;
@property(copy) NSString *_ledBellyServiceIdentifier; // @synthesize _ledBellyServiceIdentifier=__ledBellyServiceIdentifier;
@property _Bool _shouldSkipPreferredClientCertificateLookup; // @synthesize _shouldSkipPreferredClientCertificateLookup=__shouldSkipPreferredClientCertificateLookup;
@property _Bool _collectsTimingData; // @synthesize _collectsTimingData=__collectsTimingData;
@property _Bool _sessionSendsLaunchOnDemandEvents; // @synthesize _sessionSendsLaunchOnDemandEvents=__sessionSendsLaunchOnDemandEvents;
@property _Bool _preventsIdleSleepOnceConnected; // @synthesize _preventsIdleSleepOnceConnected=__preventsIdleSleepOnceConnected;
@property _Bool _allowsPowerNapScheduling; // @synthesize _allowsPowerNapScheduling=__allowsPowerNapScheduling;
@property _Bool _allowsExpensiveAccess; // @synthesize _allowsExpensiveAccess=__allowsExpensiveAccess;
@property unsigned long long _TCPAdaptiveWriteTimeout; // @synthesize _TCPAdaptiveWriteTimeout=__TCPAdaptiveWriteTimeout;
@property unsigned long long _TCPAdaptiveReadTimeout; // @synthesize _TCPAdaptiveReadTimeout=__TCPAdaptiveReadTimeout;
@property(copy) NSString *_sourceApplicationSecondaryIdentifier; // @synthesize _sourceApplicationSecondaryIdentifier=__sourceApplicationSecondaryIdentifier;
@property(copy) NSString *_sourceApplicationBundleIdentifier; // @synthesize _sourceApplicationBundleIdentifier=__sourceApplicationBundleIdentifier;
@property(copy) NSURL *_directoryForDownloadedFiles; // @synthesize _directoryForDownloadedFiles=__directoryForDownloadedFiles;
@property _Bool _requiresPowerPluggedIn; // @synthesize _requiresPowerPluggedIn=__requiresPowerPluggedIn;
@property(copy) NSArray *protocolClasses; // @synthesize protocolClasses=_protocolClasses;
@property long long HTTPMaximumConnectionsPerHost; // @synthesize HTTPMaximumConnectionsPerHost=_HTTPMaximumConnectionsPerHost;
@property(copy) NSDictionary *HTTPAdditionalHeaders; // @synthesize HTTPAdditionalHeaders=_HTTPAdditionalHeaders;
@property unsigned long long HTTPCookieAcceptPolicy; // @synthesize HTTPCookieAcceptPolicy=_HTTPCookieAcceptPolicy;
@property _Bool HTTPShouldSetCookies; // @synthesize HTTPShouldSetCookies=_HTTPShouldSetCookies;
@property _Bool HTTPShouldUsePipelining; // @synthesize HTTPShouldUsePipelining=_HTTPShouldUsePipelining;
@property int TLSMaximumSupportedProtocol; // @synthesize TLSMaximumSupportedProtocol=_TLSMaximumSupportedProtocol;
@property int TLSMinimumSupportedProtocol; // @synthesize TLSMinimumSupportedProtocol=_TLSMinimumSupportedProtocol;
@property(copy) NSDictionary *connectionProxyDictionary; // @synthesize connectionProxyDictionary=_connectionProxyDictionary;
@property _Bool sessionSendsLaunchEvents; // @synthesize sessionSendsLaunchEvents=_sessionSendsLaunchEvents;
@property(copy) NSString *sharedContainerIdentifier; // @synthesize sharedContainerIdentifier=_sharedContainerIdentifier;
@property(getter=isDiscretionary) _Bool discretionary; // @synthesize discretionary=_discretionary;
@property _Bool allowsCellularAccess; // @synthesize allowsCellularAccess=_allowsCellularAccess;
@property unsigned long long networkServiceType; // @synthesize networkServiceType=_networkServiceType;
@property double timeoutIntervalForResource; // @synthesize timeoutIntervalForResource=_timeoutIntervalForResource;
@property double timeoutIntervalForRequest; // @synthesize timeoutIntervalForRequest=_timeoutIntervalForRequest;
@property unsigned long long requestCachePolicy; // @synthesize requestCachePolicy=_requestCachePolicy;
@property(copy) NSString *identifier; // @synthesize identifier=_identifier;
- (id)sourceApplicationBundleIdentifier;
- (void)setSourceApplicationBundleIdentifier:(id)arg1;
- (struct HTTPConnectionCacheLimits)getConnectionCacheLimits;
- (void *)_copyAttribute:(struct __CFString *)arg1;
- (id)initWithCoder:(id)arg1;
- (void)encodeWithCoder:(id)arg1;
- (void)dealloc;
- (unsigned long long)hash;
- (_Bool)isEqual:(id)arg1;
- (id)copyWithZone:(struct _NSZone *)arg1;
@property(retain) NSURLCredentialStorage *URLCredentialStorage;
- (struct OpaqueCFHTTPCookieStorage *)_copyCFCookieStorage;
@property(retain) NSURLCache *URLCache;
@property(retain) NSHTTPCookieStorage *HTTPCookieStorage;
- (void)setHSTSPolicy:(struct _CFHSTSPolicy *)arg1;
- (struct _CFHSTSPolicy *)copyHSTSPolicy;
- (id)initWithDisposition:(id)arg1;

@end

@interface NSURLSessionDataTask : NSURLSessionTask
{
}

@end

@interface NSURLSessionDownloadTask : NSURLSessionTask
{
}

- (void)cancelByProducingResumeData:(CDUnknownBlockType)arg1;

@end

__attribute__((visibility("hidden")))
@interface NSURLSessionStreamTask : NSURLSessionTask
{
}

@end

@interface NSURLSessionUploadTask : NSURLSessionDataTask
{
}

@end

__attribute__((visibility("hidden")))
@interface NSURLStorage_CacheClient : NSObject <NSURLStorageCacheClient>
{
    NSXPCInterface *_netStoreInterface;
    NSXPCConnection *_networkStorageConnection;
    NSString *_taskManagerIdentifier;
    NSString *_path;
    struct __CFURLCache *_cfCache;
    NSData *_sandboxExtensionToken;
    long long _storageSize;
}

- (void)notifyCachedURLResponseBecameFileBacked:(id)arg1 filePath:(id)arg2 forUUID:(id)arg3;
- (void)setMinSizeForVMCachedResource:(long long)arg1;
- (long long)currentDiskUsage;
- (void)copyAllPartitionNamesWithCompletionHandler:(CDUnknownBlockType)arg1;
- (void)copyHostNamesForOptionalPartition:(id)arg1 handler:(CDUnknownBlockType)arg2;
- (void)deleteAllHostNames:(id)arg1 forOptionalPartition:(id)arg2;
- (void)deleteResponsesSinceDate:(id)arg1;
- (void)deleteAllResponses;
- (void)deleteResponseForRequestWithKey:(id)arg1 withCompletionHandler:(CDUnknownBlockType)arg2;
- (void)cachedResponseForKey:(id)arg1 handler:(CDUnknownBlockType)arg2;
- (void)addCachedResponseWithDictionary:(id)arg1 key:(id)arg2;
- (void)addCachedResponse:(id)arg1 key:(id)arg2;
- (_Bool)createStorageTaskManagerForPath:(id)arg1 maxSize:(long long)arg2 extension:(id)arg3 withIdentifier:(id)arg4;
- (void)setMaxSize:(long long)arg1;
- (id)getPath;
- (void)_reconnectWithStorageServer;
- (void)_disassociateCFURLCacheInstance;
- (void)_associateCFURLCacheInstance:(struct __CFURLCache *)arg1;
- (void)dealloc;
- (id)initWithCache:(struct __CFURLCache *)arg1;

@end

__attribute__((visibility("hidden")))
@interface _NSCFTranslatedFileURLProtocol : NSURLProtocol
{
    const struct CFURLProtocolInstanceCallbacks *_callbacks;
    struct CFURLProtocolClient _cfurlClient;
    const void *_info;
}

+ (_Bool)requestIsCacheEquivalent:(id)arg1 toRequest:(id)arg2;
+ (id)canonicalRequestForRequest:(id)arg1;
+ (_Bool)canInitWithRequest:(id)arg1;
+ (const struct CFURLProtocolImplementation *)pimpl;
- (id).cxx_construct;
- (void)stopLoading;
- (void)startLoading;
- (struct CFURLProtocolClient *)cfurlClient;
- (void)dealloc;
- (id)initWithRequest:(id)arg1 cachedResponse:(id)arg2 client:(id)arg3;

@end

__attribute__((visibility("hidden")))
@interface _NSCFTranslatedFileURLProtocol_PIMPL_0 : _NSCFTranslatedFileURLProtocol
{
}

+ (const struct CFURLProtocolImplementation *)pimpl;

@end

__attribute__((visibility("hidden")))
@interface _NSCFTranslatedFileURLProtocol_PIMPL_1 : _NSCFTranslatedFileURLProtocol
{
}

+ (const struct CFURLProtocolImplementation *)pimpl;

@end

__attribute__((visibility("hidden")))
@interface _NSCFTranslatedFileURLProtocol_PIMPL_2 : _NSCFTranslatedFileURLProtocol
{
}

+ (const struct CFURLProtocolImplementation *)pimpl;

@end

__attribute__((visibility("hidden")))
@interface _NSCFTranslatedFileURLProtocol_PIMPL_3 : _NSCFTranslatedFileURLProtocol
{
}

+ (const struct CFURLProtocolImplementation *)pimpl;

@end

__attribute__((visibility("hidden")))
@interface _NSCFTranslatedFileURLProtocol_PIMPL_4 : _NSCFTranslatedFileURLProtocol
{
}

+ (const struct CFURLProtocolImplementation *)pimpl;

@end

__attribute__((visibility("hidden")))
@interface _NSCFTranslatedFileURLProtocol_PIMPL_5 : _NSCFTranslatedFileURLProtocol
{
}

+ (const struct CFURLProtocolImplementation *)pimpl;

@end

__attribute__((visibility("hidden")))
@interface _NSCFTranslatedFileURLProtocol_PIMPL_6 : _NSCFTranslatedFileURLProtocol
{
}

+ (const struct CFURLProtocolImplementation *)pimpl;

@end

__attribute__((visibility("hidden")))
@interface _NSCFTranslatedFileURLProtocol_PIMPL_7 : _NSCFTranslatedFileURLProtocol
{
}

+ (const struct CFURLProtocolImplementation *)pimpl;

@end

__attribute__((visibility("hidden")))
@interface _NSCFURLProtocol : NSURLProtocol
{
    struct _CFURLProtocol *_prot;
    struct NSCFURLProtocolClient *_client;
}

+ (_Bool)requestIsCacheEquivalent:(id)arg1 toRequest:(id)arg2;
+ (id)canonicalRequestForRequest:(id)arg1 task:(id)arg2;
+ (id)canonicalRequestForRequest:(id)arg1;
+ (_Bool)canInitWithTask:(id)arg1;
+ (const struct InternalProtocolImplementation *)_cf_internalImpl;
- (void)stopLoading;
- (void)startLoading;
- (void)dealloc;
- (id)initWithRequest:(id)arg1 cachedResponse:(id)arg2 client:(id)arg3;

@end

__attribute__((visibility("hidden")))
@interface _NSCFWikipediaProtocol : NSURLProtocol
{
    const void *_instance;
    const struct CFURLProtocolInstanceCallbacks *_callbacks;
}

+ (_Bool)requestIsCacheEquivalent:(id)arg1 toRequest:(id)arg2;
+ (id)canonicalRequestForRequest:(id)arg1;
+ (_Bool)canInitWithRequest:(id)arg1;
- (void)unscheduleOnRunloop:(struct __CFRunLoop *)arg1 mode:(struct __CFString *)arg2;
- (void)scheduleOnRunloop:(struct __CFRunLoop *)arg1 mode:(struct __CFString *)arg2;
- (void)stopLoading;
- (void)startLoading;
- (void)dealloc;
- (id)initWithRequest:(id)arg1 cachedResponse:(id)arg2 client:(id)arg3;

@end

__attribute__((visibility("hidden")))
@interface _NSURLBDOnce : NSObject
{
    CDUnknownBlockType fBlock;
    _Bool fDone;
}

- (void)doit;
- (void)dealloc;
- (id)initWithBlock:(CDUnknownBlockType)arg1;

@end

__attribute__((visibility("hidden")))
@interface _NSURLDataProtocol : _NSCFURLProtocol
{
}

+ (const struct InternalProtocolImplementation *)_cf_internalImpl;

@end

__attribute__((visibility("hidden")))
@interface _NSURLFTPProtocol : _NSCFURLProtocol
{
}

+ (const struct InternalProtocolImplementation *)_cf_internalImpl;

@end

__attribute__((visibility("hidden")))
@interface _NSURLFileProtocol : _NSCFURLProtocol
{
}

+ (const struct InternalProtocolImplementation *)_cf_internalImpl;

@end

__attribute__((visibility("hidden")))
@interface _NSURLHTTPProtocol : _NSCFURLProtocol
{
}

+ (const struct InternalProtocolImplementation *)_cf_internalImpl;

@end

__attribute__((visibility("hidden")))
@interface __NSCFBackgroundSessionTask : NSURLSessionTask <NSURLSessionTaskSubclass>
{
    _Bool _sentCancel;
    id <NDBackgroundSessionProtocol> _remoteSession;
    unsigned long long _ident;
    NSError *_immediateError;
}

@property(retain) NSError *immediateError; // @synthesize immediateError=_immediateError;
@property(readonly) unsigned long long ident; // @synthesize ident=_ident;
@property(retain) id <NDBackgroundSessionProtocol> remoteSession; // @synthesize remoteSession=_remoteSession;
- (id)_timingData;
- (void)setTaskDescription:(id)arg1;
- (void)_onqueue_disavow;
- (void)_onqueue_didResume;
- (void)_onqueue_adjustPriorityHint:(float)arg1;
- (void)_onqueue_adjustPoolPriority;
- (void)_onqueue_resume;
- (void)_onqueue_cancel;
- (void)_onqueue_suspend;
- (void)_onqueue_didSendBodyBytes:(long long)arg1 totalBytesSent:(long long)arg2 totalBytesExpectedToSend:(long long)arg3;
- (void)_onqueue_didFinishWithError:(id)arg1;
- (void)_onqueue_didReceiveResponse:(id)arg1;
- (void)_onqueue_connectionWaiting;
- (void)_onqueue_willSendRequestForEstablishedConnection:(id)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)_onqueue_didReceiveChallenge:(id)arg1 request:(id)arg2 withCompletion:(CDUnknownBlockType)arg3;
- (void)dealloc;
- (id)initWithBackgroundTask:(id)arg1;
- (id)initWithTaskInfo:(id)arg1 session:(id)arg2 remoteSession:(id)arg3 ident:(unsigned long long)arg4;
- (id)initWithSession:(id)arg1 remoteSession:(id)arg2 request:(id)arg3 ident:(unsigned long long)arg4;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface __NSCFBackgroundAVAssetDownloadTask : __NSCFBackgroundSessionTask
{
    unsigned long long _downloadToken;
    unsigned long long _AVAssetDownloadToken;
    NSURL *_URL;
    NSURL *_destinationURL;
}

@property(copy) NSURL *destinationURL; // @synthesize destinationURL=_destinationURL;
@property(copy) NSURL *URL; // @synthesize URL=_URL;
@property unsigned long long AVAssetDownloadToken; // @synthesize AVAssetDownloadToken=_AVAssetDownloadToken;
- (void)_onqueue_didReceiveProgressUpdateWithTotalBytesWritten:(long long)arg1 totalBytesExpectedToWrite:(long long)arg2;
- (void)dealloc;
- (id)initWithTaskInfo:(id)arg1 session:(id)arg2 remoteSession:(id)arg3 ident:(unsigned long long)arg4;
- (id)initWithSession:(id)arg1 remoteSession:(id)arg2 URL:(id)arg3 destinationURL:(id)arg4 ident:(unsigned long long)arg5;

@end

__attribute__((visibility("hidden")))
@interface __NSCFBackgroundDataTask : __NSCFBackgroundSessionTask <NSStreamDelegate>
{
    NSInputStream *_requestBodyStream;
    NSInputStream *_initialStream;
    NSObject<OS_dispatch_queue> *_writeQueue;
    NSObject<OS_dispatch_io> *_pipeIO;
    unsigned long long _bytesRead;
    _Bool _streamBased;
    NSFileHandle *_readHandle;
}

@property(readonly, getter=isStreamBased) _Bool streamBased; // @synthesize streamBased=_streamBased;
@property(readonly) NSFileHandle *readHandle; // @synthesize readHandle=_readHandle;
- (void)stream:(id)arg1 handleEvent:(unsigned long long)arg2;
- (void)finishStream:(_Bool)arg1;
- (void)readFromStream;
- (void)_onqueue_didReceiveData:(id)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)_onqueue_didReceiveResponse:(id)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)_onqueue_didReceiveResponse:(id)arg1 redirectRequest:(id)arg2 withCompletion:(CDUnknownBlockType)arg3;
- (void)dealloc;
- (_Bool)isKindOfClass:(Class)arg1;
- (void)_onqueue_willBeRetried;
- (void)_onqueue_needNewBodyStream:(_Bool)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)captureStream:(id)arg1;
- (void)_onqueue_didFinishWithError:(id)arg1;
- (void)_onqueue_willSendRequestForEstablishedConnection:(id)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)_onqueue_openStream;
- (id)initWithSession:(id)arg1 remoteSession:(id)arg2 request:(id)arg3 ident:(unsigned long long)arg4;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface __NSCFBackgroundDownloadTask : __NSCFBackgroundSessionTask
{
    _Bool _finished;
    _Bool _suppressProgress;
}

@property _Bool suppressProgress; // @synthesize suppressProgress=_suppressProgress;
@property _Bool finished; // @synthesize finished=_finished;
- (void)cancelByProducingResumeData:(CDUnknownBlockType)arg1;
- (void)_onqueue_cancelByProducingResumeData:(CDUnknownBlockType)arg1;
- (void)_onqueue_didFinishDownloadingToURL:(id)arg1;
- (void)_onqueue_didFinishWithError:(id)arg1;
- (void)_onqueue_didResumeAtOffset:(long long)arg1 expectedTotalBytes:(long long)arg2;
- (void)_onqueue_didWriteData:(long long)arg1 totalBytesWritten:(long long)arg2 totalBytesExpectedToWrite:(long long)arg3;
- (void)_onqueue_didReceiveResponse:(id)arg1;
- (_Bool)isKindOfClass:(Class)arg1;

@end

__attribute__((visibility("hidden")))
@interface __NSCFBackgroundUploadTask : __NSCFBackgroundDataTask
{
}

- (_Bool)isKindOfClass:(Class)arg1;

@end

__attribute__((visibility("hidden")))
@interface __NSCFLocalSessionTask : NSURLSessionTask <NSURLSessionTaskSubclass, NSURLSessionDataTaskSubclass, NSURLSessionUploadTaskSubclass, SessionConnectionDelegate>
{
    _Bool _pendingResponseDisposition;
    _Bool _pendingResponseDisposition_didFinish;
    _Bool _duetAccountingIsDiscretionary;
    _Bool _didIssueDidFinish;
    __NSCFURLSessionConnection *_cfConn;
    NSURL *_uploadFile;
    NSData *_uploadData;
    NSInputStream *_uploadDataStream;
    NSObject<OS_dispatch_data> *_dataTaskData;
    CDUnknownBlockType _dataTaskCompletion;
    NSObject<OS_dispatch_data> *_pendingResponseBytes;
    __NSURLSessionLocal *_localSession;
    unsigned long long _suspendCount;
    CDUnknownBlockType _async_initialization;
    NSObject<OS_dispatch_source> *_resourceTimeout;
    NSString *_duetAccountedBundleID;
    struct HTTPConnectionCacheKey *_connKey;
    NSURLSessionConfiguration *__configuration;
}

@property(retain) NSURLSessionConfiguration *_configuration; // @synthesize _configuration=__configuration;
@property struct HTTPConnectionCacheKey *connKey; // @synthesize connKey=_connKey;
@property _Bool didIssueDidFinish; // @synthesize didIssueDidFinish=_didIssueDidFinish;
@property _Bool duetAccountingIsDiscretionary; // @synthesize duetAccountingIsDiscretionary=_duetAccountingIsDiscretionary;
@property(retain) NSString *duetAccountedBundleID; // @synthesize duetAccountedBundleID=_duetAccountedBundleID;
@property NSObject<OS_dispatch_source> *resourceTimeout; // @synthesize resourceTimeout=_resourceTimeout;
@property(copy) CDUnknownBlockType async_initialization; // @synthesize async_initialization=_async_initialization;
@property unsigned long long suspendCount; // @synthesize suspendCount=_suspendCount;
@property(retain) __NSURLSessionLocal *localSession; // @synthesize localSession=_localSession;
@property NSObject<OS_dispatch_data> *pendingResponseBytes; // @synthesize pendingResponseBytes=_pendingResponseBytes;
@property _Bool pendingResponseDisposition_didFinish; // @synthesize pendingResponseDisposition_didFinish=_pendingResponseDisposition_didFinish;
@property _Bool pendingResponseDisposition; // @synthesize pendingResponseDisposition=_pendingResponseDisposition;
@property(copy) CDUnknownBlockType dataTaskCompletion; // @synthesize dataTaskCompletion=_dataTaskCompletion;
@property NSObject<OS_dispatch_data> *dataTaskData; // @synthesize dataTaskData=_dataTaskData;
@property(retain) NSInputStream *uploadDataStream; // @synthesize uploadDataStream=_uploadDataStream;
@property(retain) NSData *uploadData; // @synthesize uploadData=_uploadData;
@property(retain) NSURL *uploadFile; // @synthesize uploadFile=_uploadFile;
@property(retain) __NSCFURLSessionConnection *cfConn; // @synthesize cfConn=_cfConn;
- (void)connection:(id)arg1 _conditionalRequirementsChanged:(_Bool)arg2;
- (void)connectionWaiting:(id)arg1;
- (void)connection:(id)arg1 _willSendRequestForEstablishedConnection:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)connection:(id)arg1 sentBodyBytes:(id)arg2 totalBytes:(id)arg3 expectedBytes:(id)arg4;
- (void)connection:(id)arg1 didReceiveData:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)connection:(id)arg1 challenged:(id)arg2 authCallback:(CDUnknownBlockType)arg3;
- (void)connection:(id)arg1 request:(id)arg2 needsNewBodyStreamCallback:(CDUnknownBlockType)arg3;
- (void)connection:(id)arg1 didReceiveConnectionCacheKey:(struct HTTPConnectionCacheKey *)arg2;
- (void)connection:(id)arg1 didFinishLoadingWithError:(id)arg2;
- (void)connectionWillFinishLoading:(id)arg1;
- (void)connection:(id)arg1 willCacheResponse:(id)arg2 responseCallback:(CDUnknownBlockType)arg3;
- (void)connection:(id)arg1 didReceiveResponse:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)connection:(id)arg1 wasRedirected:(id)arg2 newRequest:(id)arg3 responseCallback:(CDUnknownBlockType)arg4;
- (void)startResourceTimer;
- (void)setConnection:(id)arg1;
- (id)timeoutError;
- (id)posixError:(int)arg1;
- (id)canceledError;
- (id)nsurlError:(int)arg1;
- (id)error:(id)arg1 code:(long long)arg2;
- (void)_onqueue_completeInitialization;
- (void)cancel_with_error:(id)arg1;
- (void)_onqueue_disavow;
- (void)_onqueue_adjustPriorityHint:(float)arg1;
- (void)_onqueue_adjustPoolPriority;
- (void)_onqueue_resume;
- (void)_onqueue_suspend;
- (void)_onqueue_cancel;
- (void)_onqueue_cancel_with_error:(id)arg1;
- (void)_onqueue_didSendBodyBytes:(long long)arg1 totalBytesSent:(long long)arg2 totalBytesExpectedToSend:(long long)arg3;
- (void)_onqueue_conditionalRequirementsChanged:(_Bool)arg1;
- (void)_onqueue_connectionWaiting;
- (void)_onqueue_willSendRequestForEstablishedConnection:(id)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)_onqueue_needNewBodyStream:(id)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)_task_onqueue_didReceiveDispatchData:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (void)_onqueue_didReceiveDispatchData:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (void)_onqueue_didFinishWithError:(id)arg1;
- (void)_task_onqueue_didFinish;
- (void)_onqueue_willCacheResponse:(id)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)_onqueue_didReceiveChallenge:(id)arg1 request:(id)arg2 withCompletion:(CDUnknownBlockType)arg3;
- (void)_onqueue_didReceiveResponse:(id)arg1 redirectRequest:(id)arg2 withCompletion:(CDUnknownBlockType)arg3;
- (void)_private_onqueue_didReceiveResponse:(id)arg1;
- (void)_private_onqueue_didReceiveResponseDisposition:(long long)arg1;
- (void)_finishBecomeStream:(id)arg1;
- (void)_finishBecomeDownload:(id)arg1;
- (void)_finishAllow;
- (id)_onqueue_strippedMutableRequest;
@property(readonly, copy) NSString *description;
- (void)_onqueue_didReceiveResponse:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (void)dealloc;
- (id)initWithTask:(id)arg1;
- (id)initWithOriginalRequest:(id)arg1 updatedRequest:(id)arg2 ident:(unsigned long long)arg3 session:(id)arg4;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface __NSCFLocalDataTask : __NSCFLocalSessionTask
{
}

- (void)_onqueue_didReceiveResponse:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (_Bool)isKindOfClass:(Class)arg1;

@end

__attribute__((visibility("hidden")))
@interface __NSCFLocalDownloadFile : NSObject
{
    struct stat _stat;
    _Bool _finished;
    _Bool _skipUnlink;
    _Bool _truncateFile;
    int _error;
    NSObject<OS_dispatch_io> *_writeIO;
    NSObject<OS_dispatch_queue> *_workQueue;
    NSString *_path;
    id <__NSCFLocalDownloadFileOpener> _fileProvider;
    CDUnknownBlockType _finishCompletion;
}

@property(copy) CDUnknownBlockType finishCompletion; // @synthesize finishCompletion=_finishCompletion;
@property id <__NSCFLocalDownloadFileOpener> fileProvider; // @synthesize fileProvider=_fileProvider;
@property int error; // @synthesize error=_error;
@property _Bool truncateFile; // @synthesize truncateFile=_truncateFile;
@property _Bool skipUnlink; // @synthesize skipUnlink=_skipUnlink;
@property(retain) NSString *path; // @synthesize path=_path;
@property _Bool finished; // @synthesize finished=_finished;
@property NSObject<OS_dispatch_queue> *workQueue; // @synthesize workQueue=_workQueue;
@property NSObject<OS_dispatch_io> *writeIO; // @synthesize writeIO=_writeIO;
- (id).cxx_construct;
- (void)captureFile:(id *)arg1 outStat:(struct stat *)arg2;
- (id)fileURL;
- (void)finishOnQueue:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (void)writeBytes:(id)arg1 completionQueue:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)truncate;
- (void)dealloc;
- (id)ioChannel;
- (id)initWithExistingUnopenableFile:(id)arg1 fileProvider:(id)arg2;
- (id)initWithExistingFile:(id)arg1 expectedSize:(long long)arg2;
- (id)initTempFileWithDirectory:(id)arg1;
- (id)initQueues;

@end

__attribute__((visibility("hidden")))
@interface __NSCFLocalDownloadTask : __NSCFLocalSessionTask <NSURLSessionDownloadTaskSubclass, __NSCFLocalDownloadFileOpener>
{
    _Bool _canWrite;
    _Bool _suppressProgress;
    _Bool _needFinish;
    _Bool _didIssueNeedFinish;
    int _seqNo;
    CDUnknownBlockType _fileCompletion;
    __NSCFLocalDownloadFile *_downloadFile;
    NSObject<OS_dispatch_data> *_writeBuffer;
    unsigned long long _ioSuspend;
    unsigned long long _totalWrote;
    CDUnknownBlockType _resumeCallback;
    long long _initialResumeSize;
    NSDictionary *_originalResumeInfo;
    unsigned long long __transientWriteProgress;
    CDUnknownBlockType __afterDidReportProgressOnQueue;
}

@property(copy) CDUnknownBlockType _afterDidReportProgressOnQueue; // @synthesize _afterDidReportProgressOnQueue=__afterDidReportProgressOnQueue;
@property unsigned long long _transientWriteProgress; // @synthesize _transientWriteProgress=__transientWriteProgress;
@property(retain) NSDictionary *originalResumeInfo; // @synthesize originalResumeInfo=_originalResumeInfo;
@property long long initialResumeSize; // @synthesize initialResumeSize=_initialResumeSize;
@property(copy) CDUnknownBlockType resumeCallback; // @synthesize resumeCallback=_resumeCallback;
@property unsigned long long totalWrote; // @synthesize totalWrote=_totalWrote;
@property _Bool didIssueNeedFinish; // @synthesize didIssueNeedFinish=_didIssueNeedFinish;
@property _Bool needFinish; // @synthesize needFinish=_needFinish;
@property int seqNo; // @synthesize seqNo=_seqNo;
@property unsigned long long ioSuspend; // @synthesize ioSuspend=_ioSuspend;
@property NSObject<OS_dispatch_data> *writeBuffer; // @synthesize writeBuffer=_writeBuffer;
@property _Bool suppressProgress; // @synthesize suppressProgress=_suppressProgress;
@property _Bool canWrite; // @synthesize canWrite=_canWrite;
@property(retain) __NSCFLocalDownloadFile *downloadFile; // @synthesize downloadFile=_downloadFile;
@property(copy) CDUnknownBlockType fileCompletion; // @synthesize fileCompletion=_fileCompletion;
- (_Bool)isKindOfClass:(Class)arg1;
- (void)_task_onqueue_didFinish;
- (void)_task_onqueue_didReceiveDispatchData:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (void)_onqueue_didReceiveResponse:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (void)checkWrite;
- (void)_private_fileCompletion;
- (void)_private_errorCompletion;
- (id)createResumeInformation:(id)arg1;
- (void)writeAndResume;
- (void)_onqueue_willCacheResponse:(id)arg1 withCompletion:(CDUnknownBlockType)arg2;
- (void)_private_posixError:(int)arg1;
- (void)reportProgress:(unsigned long long)arg1;
- (void)cancelByProducingResumeData:(CDUnknownBlockType)arg1;
- (void)_onqueue_cancelByProducingResumeData:(CDUnknownBlockType)arg1;
- (void)_onqueue_completeInitialization;
- (int)openItemForPath:(id)arg1 mode:(int)arg2;
- (void)dealloc;
- (id)initWithTask:(id)arg1;
- (id)initWithSession:(id)arg1 resumeData:(id)arg2 ident:(unsigned long long)arg3;
- (id)initWithSession:(id)arg1 request:(id)arg2 filePath:(id)arg3 ident:(unsigned long long)arg4;
- (id)initWithSession:(id)arg1 request:(id)arg2 ident:(unsigned long long)arg3;
- (_Bool)setupForNewDownload:(id)arg1;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface __NSCFLocalStreamTask : __NSCFLocalSessionTask <NSURLSessionStreamTaskSubclass>
{
    struct __CFWriteStream *_sinkForResponseBytes;
    NSObject<OS_dispatch_data> *_buffer;
    CDUnknownBlockType _streamCompletion;
}

+ (id)rawRequestForHost:(id)arg1 port:(long long)arg2 tls:(_Bool)arg3;
@property(copy) CDUnknownBlockType streamCompletion; // @synthesize streamCompletion=_streamCompletion;
- (void)_onqueue_resume;
- (void)_onqueue_suspend;
- (void)_onqueue_cancel;
- (void)_onqueue_adjustPriorityHint:(float)arg1;
- (void)_onqueue_adjustPoolPriority;
- (void)_onqueue_newStreams;
- (void)_task_onqueue_didFinish;
- (void)_onqueue_createBoundStreams;
- (void)_task_onqueue_didReceiveDispatchData:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (void)_onqueue_issueWrite;
- (id)initWithTask:(id)arg1;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface __NSCFLocalUploadTask : __NSCFLocalDataTask
{
}

- (_Bool)isKindOfClass:(Class)arg1;

@end

__attribute__((visibility("hidden")))
@interface __NSCFMemoryHTTPCookieStorage : NSHTTPCookieStorage
{
}

+ (void)initialize;
- (id)sortedCookiesUsingDescriptors:(id)arg1;
- (void)setCookieAcceptPolicy:(unsigned long long)arg1;
- (unsigned long long)cookieAcceptPolicy;
- (void)setCookies:(id)arg1 forURL:(id)arg2 mainDocumentURL:(id)arg3;
- (id)cookiesForURL:(id)arg1;
- (void)deleteCookie:(id)arg1;
- (void)setCookie:(id)arg1;
- (id)cookies;
- (id)description;
- (id)init;

@end

__attribute__((visibility("hidden")))
@interface __NSCFMemoryURLCache : NSObject
{
    id _internal;
    unsigned long long _memoryCapacity;
    unsigned long long _currentLength;
    NSMutableDictionary *_memoryStorage;
    NSMutableArray *_memoryStorageLRU;
    NSObject<OS_dispatch_queue> *_memoryQueue;
}

+ (void)initialize;
- (unsigned long long)currentDiskUsage;
- (unsigned long long)currentMemoryUsage;
- (void)setDiskCapacity:(unsigned long long)arg1;
- (void)setMemoryCapacity:(unsigned long long)arg1;
- (unsigned long long)diskCapacity;
- (unsigned long long)memoryCapacity;
- (void)removeAllCachedResponses;
- (void)removeCachedResponseForRequest:(id)arg1;
- (void)storeCachedResponse:(id)arg1 forRequest:(id)arg2;
- (id)cachedResponseForRequest:(id)arg1;
- (id)description;
- (id)initMemoryCache;
- (id)initEmptyCache;
- (void)dealloc;
- (id)initWithMemoryCapacity:(unsigned long long)arg1 diskCapacity:(unsigned long long)arg2 diskPath:(id)arg3;
- (id)initByCallingSuperSuperInit;

@end

__attribute__((visibility("hidden")))
@interface __NSCFMemoryURLCredentialStorage : NSObject
{
}

+ (void)initialize;
- (void)setDefaultCredential:(id)arg1 forProtectionSpace:(id)arg2;
- (id)defaultCredentialForProtectionSpace:(id)arg1;
- (void)removeCredential:(id)arg1 forProtectionSpace:(id)arg2;
- (void)setCredential:(id)arg1 forProtectionSpace:(id)arg2;
- (id)allCredentials;
- (id)credentialsForProtectionSpace:(id)arg1;
- (id)description;
- (id)init;

@end

__attribute__((visibility("hidden")))
@interface __NSCFURLProtocolClient_NS : NSObject <NSURLProtocolClient>
{
    struct URLProtocolClient *_cf;
    struct URLProtocol *_prot;
    NSURLAuthenticationChallenge *_challenge;
    struct _CFURLAuthChallenge *_cfChallenge;
}

- (void)URLProtocol:(id)arg1 didCancelAuthenticationChallenge:(id)arg2;
- (void)URLProtocol:(id)arg1 didReceiveAuthenticationChallenge:(id)arg2;
- (void)URLProtocol:(id)arg1 didFailWithError:(id)arg2;
- (void)URLProtocolDidFinishLoading:(id)arg1;
- (void)URLProtocol:(id)arg1 didLoadData:(id)arg2;
- (void)URLProtocol:(id)arg1 didReceiveResponse:(id)arg2 cacheStoragePolicy:(unsigned long long)arg3;
- (void)URLProtocol:(id)arg1 cachedResponseIsValid:(id)arg2;
- (void)URLProtocol:(id)arg1 wasRedirectedToRequest:(id)arg2 redirectResponse:(id)arg3;
- (struct _CFURLAuthChallenge *)cfChallenge;
- (id)challenge;
- (void)teardown;
- (void)dealloc;
- (id)initWithCFClient:(struct URLProtocolClient *)arg1 prot:(struct URLProtocol *)arg2;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface __NSCFURLSessionConnection : NSObject <NSURLAuthenticationChallengeSender, NSCopying>
{
    struct SessionConnectionLoadable *_loaderClient;
    struct URLConnectionLoader *_loader;
    NSObject<OS_dispatch_queue> *_workQueue;
    _Bool _canceled;
    long long _suspended;
    NSURLResponse *_currentResponse;
    NSObject<OS_dispatch_data> *_pendingData;
    long long _pendingCompletion;
    unsigned long long _didReceiveResponseDisposition;
    NSError *_pendingError;
    int _state;
    NSURLResponse *_cacheResponse;
    NSObject<OS_dispatch_data> *_cacheData;
    unsigned long long _cacheDataMax;
    long long _clientBufferLength;
    NSObject<OS_dispatch_data> *_sniffData;
    NSURLResponse *_sniffResponse;
    _Bool _isMixedReplace;
    _Bool _didCheckMixedReplace;
    NSURLSessionTask *_task;
    id <SessionConnectionDelegate> _delegate;
    NSObject<OS_dispatch_queue> *_delegateQueue;
}

@property NSObject<OS_dispatch_queue> *delegateQueue; // @synthesize delegateQueue=_delegateQueue;
@property(retain) id <SessionConnectionDelegate> delegate; // @synthesize delegate=_delegate;
@property(copy) NSURLSessionTask *task; // @synthesize task=_task;
- (void)cancelAuthenticationChallenge:(id)arg1;
- (void)continueWithoutCredentialForAuthenticationChallenge:(id)arg1;
- (void)useCredential:(id)arg1 forAuthenticationChallenge:(id)arg2;
- (void)_needNewBodyStream;
- (void)_didReceiveChallenge:(id)arg1;
- (void)_redirectRequest:(id)arg1 redirectResponse:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)_conditionalRequirementsChanged:(_Bool)arg1;
- (void)_connectionIsWaiting;
- (void)_willSendRequestForEstablishedConnection:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (void)_didReceiveConnectionCacheKey:(struct HTTPConnectionCacheKey *)arg1;
- (void)_didFinishWithError:(id)arg1;
- (void)_didSendBodyData:(struct UploadProgressInfo)arg1;
- (void)_didReceiveData:(id)arg1;
- (void)_didReceiveResponse:(id)arg1 sniff:(_Bool)arg2;
- (void)_tick;
- (void)_tick_finishing;
- (void)_task_sendFinish;
- (void)_tick_running;
- (void)_tick_sniffNow;
- (void)_tick_initialize;
- (void)_tossCache;
- (void)_setupForCache:(_Bool)arg1 expectedLength:(long long)arg2 response:(id)arg3;
- (void)withWorkQueueAsync:(CDUnknownBlockType)arg1;
- (void)setPriorityHint:(float)arg1;
- (void)setPoolPriority:(long long)arg1;
- (void)resume;
- (void)suspend;
- (void)cancel;
- (void)withLoaderAsync:(CDUnknownBlockType)arg1;
- (void)withLoaderOnQueue:(CDUnknownBlockType)arg1;
- (void)afterDelegateWithTick:(CDUnknownBlockType)arg1;
- (void)withDelegateAndPendingCompletionAsync:(CDUnknownBlockType)arg1;
- (void)_cleanup;
- (id)copyWithZone:(struct _NSZone *)arg1;
- (void)dealloc;
- (id)initWithTask:(id)arg1 delegate:(id)arg2 delegateQueue:(id)arg3;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

@interface __NSCFURLSessionTaskInfo : NSObject <NSSecureCoding>
{
    _Bool _hasStarted;
    _Bool _expectingResumeCallback;
    _Bool _establishedConnection;
    _Bool _disablesRetry;
    _Bool _shouldCancelOnDisconnect;
    _Bool _discretionary;
    unsigned long long _identifier;
    unsigned long long _taskKind;
    double _creationTime;
    long long _state;
    unsigned long long _suspendCount;
    NSString *_taskDescription;
    NSURLRequest *_originalRequest;
    NSURLRequest *_currentRequest;
    NSURLResponse *_response;
    NSError *_error;
    NSURL *_fileURL;
    NSURL *_downloadFileURL;
    NSString *_bundleID;
    NSString *_sessionID;
    unsigned long long _retryCount;
    unsigned long long _lowThroughputTimerRetryCount;
    long long _basePriority;
    NSString *_uniqueIdentifier;
    unsigned long long _AVAssetDownloadToken;
    NSURL *_URL;
    NSURL *_destinationURL;
    NSDictionary *_options;
    long long _countOfBytesReceived;
    long long _countOfBytesSent;
    long long _countOfBytesExpectedToSend;
    long long _countOfBytesExpectedToReceive;
    NSDictionary *__backgroundTaskTimingData;
}

+ (_Bool)supportsSecureCoding;
@property(copy) NSDictionary *_backgroundTaskTimingData; // @synthesize _backgroundTaskTimingData=__backgroundTaskTimingData;
@property long long countOfBytesExpectedToReceive; // @synthesize countOfBytesExpectedToReceive=_countOfBytesExpectedToReceive;
@property long long countOfBytesExpectedToSend; // @synthesize countOfBytesExpectedToSend=_countOfBytesExpectedToSend;
@property long long countOfBytesSent; // @synthesize countOfBytesSent=_countOfBytesSent;
@property long long countOfBytesReceived; // @synthesize countOfBytesReceived=_countOfBytesReceived;
@property(retain) NSDictionary *options; // @synthesize options=_options;
@property(copy) NSURL *destinationURL; // @synthesize destinationURL=_destinationURL;
@property(copy) NSURL *URL; // @synthesize URL=_URL;
@property unsigned long long AVAssetDownloadToken; // @synthesize AVAssetDownloadToken=_AVAssetDownloadToken;
@property(retain) NSString *uniqueIdentifier; // @synthesize uniqueIdentifier=_uniqueIdentifier;
@property(getter=isDiscretionary) _Bool discretionary; // @synthesize discretionary=_discretionary;
@property long long basePriority; // @synthesize basePriority=_basePriority;
@property _Bool shouldCancelOnDisconnect; // @synthesize shouldCancelOnDisconnect=_shouldCancelOnDisconnect;
@property _Bool disablesRetry; // @synthesize disablesRetry=_disablesRetry;
@property unsigned long long lowThroughputTimerRetryCount; // @synthesize lowThroughputTimerRetryCount=_lowThroughputTimerRetryCount;
@property unsigned long long retryCount; // @synthesize retryCount=_retryCount;
@property _Bool establishedConnection; // @synthesize establishedConnection=_establishedConnection;
@property _Bool expectingResumeCallback; // @synthesize expectingResumeCallback=_expectingResumeCallback;
@property _Bool hasStarted; // @synthesize hasStarted=_hasStarted;
@property(retain) NSString *sessionID; // @synthesize sessionID=_sessionID;
@property(retain) NSString *bundleID; // @synthesize bundleID=_bundleID;
@property(retain) NSURL *downloadFileURL; // @synthesize downloadFileURL=_downloadFileURL;
@property(retain) NSURL *fileURL; // @synthesize fileURL=_fileURL;
@property(copy) NSError *error; // @synthesize error=_error;
@property(copy) NSURLResponse *response; // @synthesize response=_response;
@property(copy) NSURLRequest *currentRequest; // @synthesize currentRequest=_currentRequest;
@property(copy) NSURLRequest *originalRequest; // @synthesize originalRequest=_originalRequest;
@property(copy) NSString *taskDescription; // @synthesize taskDescription=_taskDescription;
@property unsigned long long suspendCount; // @synthesize suspendCount=_suspendCount;
@property long long state; // @synthesize state=_state;
@property double creationTime; // @synthesize creationTime=_creationTime;
@property unsigned long long taskKind; // @synthesize taskKind=_taskKind;
@property unsigned long long identifier; // @synthesize identifier=_identifier;
- (id)initWithCoder:(id)arg1;
- (void)encodeWithCoder:(id)arg1;
- (id)initWithAVAssetDownloadURL:(id)arg1 destinationURL:(id)arg2 options:(id)arg3 taskIdentifier:(unsigned long long)arg4 bundleID:(id)arg5 sessionID:(id)arg6;
- (void)dealloc;
- (id)initWithDownloadTask:(id)arg1 bundleID:(id)arg2 sessionID:(id)arg3;
- (id)initWithUploadTask:(id)arg1 bundleID:(id)arg2 sessionID:(id)arg3;
- (id)initWithDataTask:(id)arg1 bundleID:(id)arg2 sessionID:(id)arg3;
- (id)initWithTask:(id)arg1 bundleID:(id)arg2 sessionID:(id)arg3;

@end

@interface __NSCFURLSessionXPC : NSObject
{
}

+ (id)bgSessionManagerInterface;
+ (id)bgSessionClientInterface;
+ (id)bgSessionInterface;
+ (void)initialize;

@end

__attribute__((visibility("hidden")))
@interface __NSHostExtraIvars : NSObject
{
    NSString *thingToResolve;
    int resolveType;
    NSObject<OS_dispatch_queue> *resolveQueue;
    NSObject<OS_dispatch_queue> *cacheAccessQueue;
    NSObject<OS_dispatch_queue> *callbackQueue;
    _Bool startedResolving;
}

@property _Bool startedResolving; // @synthesize startedResolving;
@property(readonly) NSObject<OS_dispatch_queue> *callbackQueue; // @synthesize callbackQueue;
@property(readonly) NSObject<OS_dispatch_queue> *cacheAccessQueue; // @synthesize cacheAccessQueue;
@property(readonly) NSObject<OS_dispatch_queue> *resolveQueue; // @synthesize resolveQueue;
@property(retain, nonatomic) NSString *thingToResolve; // @synthesize thingToResolve;
@property(nonatomic) int resolveType; // @synthesize resolveType;
- (void)dealloc;
- (void)finalize;
- (void)cleanup;
- (id)init;

@end

__attribute__((visibility("hidden")))
@interface __NSURLBackgroundSession : NSURLSession <NDBackgroundSessionClient, NSURLSessionSubclass>
{
    unsigned long long _identSeed;
    id <NDBackgroundSessionProtocol> _remoteSession;
    NSXPCConnection *_xpcConn;
    NSMutableDictionary *_tasks;
    NSMutableArray *_taskIDsToFailOnReconnection;
    NSObject<OS_dispatch_queue> *_invalidateQueue;
    CDUnknownBlockType _invalidateCallback;
    NSString *_appWakeUUID;
    NSURL *_downloadDirectory;
    _Bool _isPrivileged;
    _Bool _isInvalid;
}

@property(copy) NSString *appWakeUUID; // @synthesize appWakeUUID=_appWakeUUID;
- (void)_onqueue_getTasksWithCompletionHandler:(CDUnknownBlockType)arg1;
- (void)_onqueue_completeInvalidation:(_Bool)arg1;
- (void)credStorage_setDefaultCredential:(id)arg1 forProtectionSpace:(id)arg2;
- (void)credStorage_defaultCredentialForProtectionSpace:(id)arg1 reply:(CDUnknownBlockType)arg2;
- (void)credStorage_removeCredential:(id)arg1 forProtectionSpace:(id)arg2;
- (void)credStorage_setCredential:(id)arg1 forProtectionSpace:(id)arg2;
- (void)credStorage_credentialsForProtectionSpace:(id)arg1 reply:(CDUnknownBlockType)arg2;
- (void)credStorage_allCredentialsWithReply:(CDUnknownBlockType)arg1;
- (void)credStorage_getInitialCredentialDictionariesWithReply:(CDUnknownBlockType)arg1;
- (void)backgroundSessionDidFinishAppWake:(id)arg1 reply:(CDUnknownBlockType)arg2;
- (void)backgroundSessionDidStartAppWake:(id)arg1 reply:(CDUnknownBlockType)arg2;
- (void)backgroundAVAssetDownloadTask:(unsigned long long)arg1 didReceiveDownloadToken:(unsigned long long)arg2;
- (void)backgroundAVAssetDownloadTaskDidUpdateProgress:(unsigned long long)arg1 totalBytesWritten:(unsigned long long)arg2 totalBytesExpectedToWrite:(unsigned long long)arg3;
- (void)openFileAtPath:(id)arg1 mode:(int)arg2 withReply:(CDUnknownBlockType)arg3;
- (void)backgroundDownloadTask:(unsigned long long)arg1 didResumeAtOffset:(long long)arg2 expectedTotalBytes:(long long)arg3;
- (void)backgroundDownloadTask:(unsigned long long)arg1 didWriteData:(long long)arg2 totalBytesWritten:(long long)arg3 totalBytesExpectedToWrite:(long long)arg4;
- (void)backgroundDownloadTask:(unsigned long long)arg1 didFinishDownloadingToURL:(id)arg2 reply:(CDUnknownBlockType)arg3;
- (void)willRetryBackgroundDataTask:(unsigned long long)arg1 withError:(id)arg2 timingData:(id)arg3;
- (void)backgroundDataTaskDidBecomeDownloadTask:(unsigned long long)arg1;
- (void)backgroundDataTask:(unsigned long long)arg1 didReceiveData:(id)arg2 withReply:(CDUnknownBlockType)arg3;
- (void)backgroundTask:(unsigned long long)arg1 didCompleteWithError:(id)arg2 timingData:(id)arg3 reply:(CDUnknownBlockType)arg4;
- (void)backgroundTask:(unsigned long long)arg1 needNewBodyStream:(_Bool)arg2 withReply:(CDUnknownBlockType)arg3;
- (void)backgroundTask:(unsigned long long)arg1 didSendBodyData:(long long)arg2 totalBytesSent:(long long)arg3 totalBytesExpectedToSend:(long long)arg4;
- (void)backgroundTask:(unsigned long long)arg1 didReceiveResponse:(id)arg2 timingData:(id)arg3 reply:(CDUnknownBlockType)arg4;
- (void)backgroundTask:(unsigned long long)arg1 didReceiveResponse:(id)arg2 timingData:(id)arg3;
- (void)backgroundTaskHasConnectionWaiting:(unsigned long long)arg1;
- (void)backgroundTask:(unsigned long long)arg1 _willSendRequestForEstablishedConnection:(id)arg2 reply:(CDUnknownBlockType)arg3;
- (void)backgroundTask:(unsigned long long)arg1 willPerformHTTPRedirectionWithNewRequest:(id)arg2 reply:(CDUnknownBlockType)arg3;
- (void)backgroundTask:(unsigned long long)arg1 didReceiveChallenge:(id)arg2 reply:(CDUnknownBlockType)arg3;
- (void)backgroundTaskDidSuspend:(unsigned long long)arg1;
- (void)backgroundTaskDidResume:(unsigned long long)arg1;
- (void)_onqueue_resetStorageWithCompletionHandler:(CDUnknownBlockType)arg1;
- (void)_onqueue_flushWithCompletionHandler:(CDUnknownBlockType)arg1;
- (id)_onqueue_AVAssetDownloadTaskForURL:(id)arg1 destinationURL:(id)arg2 options:(id)arg3;
- (id)_AVAssetDownloadTaskForURL:(id)arg1 destinationURL:(id)arg2 options:(id)arg3;
- (id)_onqueue_downloadTaskForRequest:(id)arg1 resumeData:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (id)_downloadTaskForRequest:(id)arg1;
- (id)_downloadTaskForResumeData:(id)arg1;
- (id)downloadTaskForRequest:(id)arg1 downloadFilePath:(id)arg2 resumeData:(id)arg3 completion:(CDUnknownBlockType)arg4;
- (id)_onqueue_uploadTaskForRequest:(id)arg1 uploadFile:(id)arg2 bodyData:(id)arg3 completion:(CDUnknownBlockType)arg4;
- (id)uploadTaskForRequest:(id)arg1 uploadFile:(id)arg2 bodyData:(id)arg3 completion:(CDUnknownBlockType)arg4;
- (id)_onqueue_dataTaskForRequest:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (id)dataTaskForRequest:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (void)performBlockOnQueueAndRethrowExceptions:(CDUnknownBlockType)arg1;
- (id)disconnectedErrorWithURL:(id)arg1;
- (id)placeholderErrorWithURL:(id)arg1;
- (id)_streamTaskForHost:(id)arg1 port:(long long)arg2 tls:(_Bool)arg3 completionHandler:(CDUnknownBlockType)arg4;
- (void)validateUploadFile:(id)arg1;
- (void)validateSerializabilityForRequest:(id)arg1 completion:(id)arg2;
- (id)_onqueue_dummyTaskForClass:(Class)arg1 withError:(id)arg2;
- (id)requestWithCookiesApplied:(id)arg1;
- (void)setCookiesFromResponse:(id)arg1 forOriginalRequest:(id)arg2;
- (void)_onqueue_disavowTask:(id)arg1;
- (id)taskForIdentifier:(unsigned long long)arg1;
- (id)copyTasks;
- (void)dealloc;
- (void)cameIntoForeground:(id)arg1;
- (void)wentToBackground:(id)arg1;
- (void)failDisconnectedTasks;
- (void)recreateExistingTasks:(id)arg1;
- (void)setupBackgroundSession;
- (id)cachesDirectory;
- (void)_onqueue_invalidateSession:(_Bool)arg1 withQueue:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)sendInvalidationRequest;
- (void)_onqueue_invokeInvalidateCallback;
- (id)initWithConfiguration:(id)arg1 delegate:(id)arg2 delegateQueue:(id)arg3;
- (void)cleanupConfig;
- (void)setupXPCConnection;
- (id)backgroundDownloadsDirectory;
- (id)backgroundResumeDataFromClientResumeData:(id)arg1;
- (id)clientResumeDataFromBackgroundResumeData:(id)arg1;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface __NSURLSessionLocal : NSURLSession <NSURLSessionSubclass>
{
    unsigned long long _identSeed;
    struct XTubeManager *_tubeManager;
    NSMutableDictionary *_tasks;
    NSObject<OS_dispatch_queue> *_invalidateQueue;
    CDUnknownBlockType _invalidateCallback;
    const struct XURLCache *_xCache;
    long long _xCacheOnce;
    const struct XCookieStorage *_xCookies;
    long long _xCookiesOnce;
    const struct XCredentialStorage *_xCreds;
    long long _xCredsOnce;
    NSArray *_localProtocolClassesForDefaultSession;
    _Bool _isInvalid;
}

- (void)_removeProtocolClassForDefaultSession:(Class)arg1;
- (_Bool)_prependProtocolClassForDefaultSession:(Class)arg1;
- (struct URLProtocol *)_newURLProtocolForTask:(id)arg1 client:(struct URLProtocolClient *)arg2;
- (struct URLProtocol *)_newURLProtocolForTask:(id)arg1 client:(struct URLProtocolClient *)arg2 protocolClass:(Class)arg3;
- (_Bool)_cfurlRequest:(struct _CFURLRequest *)arg1 isCacheEquivalentTo:(struct _CFURLRequest *)arg2;
- (_Bool)_request:(id)arg1 isCacheEquivalentTo:(id)arg2;
- (id)_createCanonicalRequestForTask:(id)arg1;
- (id)_createCanonicalRequest:(id)arg1;
- (Class)_protocolClassForRequest:(id)arg1;
- (Class)_protocolClassForTask:(id)arg1;
- (id)_protocolClasses;
- (struct Tube *)_withConnectionCache_getPendingTubeForProtocol:(struct MetaConnectionCacheClient *)arg1 withKey:(const struct HTTPConnectionCacheKey *)arg2 scheduling:(const struct CoreSchedulingSet *)arg3;
- (_Bool)_withConnectionCache_enqueueRequest:(const struct HTTPRequestMessage *)arg1 forProtocol:(struct MetaConnectionCacheClient *)arg2 scheduling:(const struct CoreSchedulingSet *)arg3 options:(struct MetaConnectionOptions)arg4;
- (void)_withConnectionCache_setCurrentSSLMethod:(struct __CFString *)arg1 forKey:(const struct HTTPConnectionCacheKey *)arg2 scheduling:(const struct CoreSchedulingSet *)arg3;
- (struct __CFString *)_withConnectionCache_getCurrentSSLMethodForKey:(const struct HTTPConnectionCacheKey *)arg1 scheduling:(const struct CoreSchedulingSet *)arg2;
- (void)_getCookieHeadersForTask:(id)arg1 completionHandler:(CDUnknownBlockType)arg2;
- (const struct XCookieStorage *)copyBaseStorageForRequest:(struct _CFURLRequest *)arg1;
- (id)_createTaskFromOriginalCFURLRequest:(struct _CFURLRequest *)arg1 updatedCFURLRequest:(struct _CFURLRequest *)arg2 connProps:(struct __CFDictionary *)arg3 sockProps:(struct __CFDictionary *)arg4;
- (void)invalidateUnpurgeableConnectionsForConnectionCacheKey:(struct HTTPConnectionCacheKey *)arg1;
- (void)_purgeIdleConnections;
- (void)_invalidateAllConnections;
- (const struct XCredentialStorage *)_createXCredentialStorage;
- (const struct XCredentialStorage *)_createXCredentialStorage0;
- (const struct XCookieStorage *)_createXCookieStorage;
- (const struct XCookieStorage *)_createXCookieStorage0;
- (const struct XURLCache *)_createXURLCache;
- (const struct XURLCache *)_createXURLCache0;
- (struct _CFHSTSPolicy *)_copyHSTSPolicy;
- (void)_onqueue_completeInvalidation:(_Bool)arg1;
- (struct XTubeManager *)_actualTubeManager;
- (void)_onqueue_getTasksWithCompletionHandler:(CDUnknownBlockType)arg1;
- (void)_onqueue_flushWithCompletionHandler:(CDUnknownBlockType)arg1;
- (void)_onqueue_resetStorageWithCompletionHandler:(CDUnknownBlockType)arg1;
- (void)task:(id)arg1 terminatedConnection:(id)arg2;
- (id)_streamTaskForHost:(id)arg1 port:(long long)arg2 tls:(_Bool)arg3 completionHandler:(CDUnknownBlockType)arg4;
- (id)_AVAssetDownloadTaskForURL:(id)arg1 destinationURL:(id)arg2 options:(id)arg3;
- (id)downloadTaskForRequest:(id)arg1 downloadFilePath:(id)arg2 resumeData:(id)arg3 completion:(CDUnknownBlockType)arg4;
- (id)uploadTaskForRequest:(id)arg1 uploadFile:(id)arg2 bodyData:(id)arg3 completion:(CDUnknownBlockType)arg4;
- (id)dataTaskForRequest:(id)arg1 completion:(CDUnknownBlockType)arg2;
- (void)dealloc;
- (id)initWithConfiguration:(id)arg1 delegate:(id)arg2 delegateQueue:(id)arg3;
- (void)_flushOrResetStorage:(CDUnknownBlockType)arg1 reset:(unsigned char)arg2;
- (void)_onqueue_invalidateSession:(_Bool)arg1 withQueue:(id)arg2 completion:(CDUnknownBlockType)arg3;
- (void)_onqueue_checkForCompletion;
- (void)_onqueue_invokeInvalidateCallback;
- (id)taskForClass:(Class)arg1 request:(id)arg2 uploadFile:(id)arg3 bodyData:(id)arg4 completion:(CDUnknownBlockType)arg5;
- (unsigned long long)nextSeed;
- (void)_onqueue_connectUploadTask:(id)arg1 strippedRequest:(id)arg2 bodyStream:(id)arg3 bodyParts:(id)arg4;
- (id)copyTasks;
- (void)replaceTask:(id)arg1 withTask:(id)arg2;
- (id)connToTask:(id)arg1;
- (id)copyWithZone:(struct _NSZone *)arg1;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end


//
//     Generated by class-dump 3.5 (64 bit).
//
//     class-dump is Copyright (C) 1997-1998, 2000-2001, 2004-2013 by Steve Nygard.
//

#pragma mark Blocks

typedef void (^CDUnknownBlockType)(void); // return type and parameters are unknown

#pragma mark Named Structures

struct _NSRange {
    unsigned long long _field1;
    unsigned long long _field2;
};

struct __hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>;

struct __hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>;

struct __hash_node<std::__1::basic_string<char>, void *>;

struct set<std::__1::basic_string<char>, std::__1::less<std::__1::basic_string<char>>, std::__1::allocator<std::__1::basic_string<char>>> {
    struct __tree<std::__1::basic_string<char>, std::__1::less<std::__1::basic_string<char>>, std::__1::allocator<std::__1::basic_string<char>>> {
        struct __tree_node<std::__1::basic_string<char>, void *> *__begin_node_;
        struct __compressed_pair<std::__1::__tree_end_node<std::__1::__tree_node_base<void *>*>, std::__1::allocator<std::__1::__tree_node<std::__1::basic_string<char>, void *>>> {
            struct __tree_end_node<std::__1::__tree_node_base<void *>*> {
                struct __tree_node_base<void *> *__left_;
            } __first_;
        } __pair1_;
        struct __compressed_pair<unsigned long, std::__1::less<std::__1::basic_string<char>>> {
            unsigned long long __first_;
        } __pair3_;
    } __tree_;
};

struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>> {
        struct __hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>*>>> {
        struct __hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unique_ptr<std::__1::__hash_node<std::__1::basic_string<char>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::basic_string<char>, void *>*>>> {
    struct __compressed_pair<std::__1::__hash_node<std::__1::basic_string<char>, void *>**, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::basic_string<char>, void *>*>>> {
        struct __hash_node<std::__1::basic_string<char>, void *> **__first_;
        struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::basic_string<char>, void *>*>> {
            struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node<std::__1::basic_string<char>, void *>*>> {
                unsigned long long __first_;
            } __data_;
        } __second_;
    } __ptr_;
};

struct unordered_multimap<std::__1::basic_string<char>, const tokenPayload, std::__1::hash<std::__1::basic_string<char>>, std::__1::equal_to<std::__1::basic_string<char>>, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, const tokenPayload>>> {
    struct __hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::hash<std::__1::basic_string<char>>, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::equal_to<std::__1::basic_string<char>>, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>>> {
        struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>> __bucket_list_;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*> {
                struct __hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *> *__next_;
            } __first_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::hash<std::__1::basic_string<char>>, true>> {
            unsigned long long __first_;
        } __p2_;
        struct __compressed_pair<float, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, std::__1::equal_to<std::__1::basic_string<char>>, true>> {
            float __first_;
        } __p3_;
    } __table_;
};

struct unordered_multimap<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>, std::__1::hash<std::__1::basic_string<char>>, std::__1::equal_to<std::__1::basic_string<char>>, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>>> {
    struct __hash_table<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, std::__1::hash<std::__1::basic_string<char>>, true>, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, std::__1::equal_to<std::__1::basic_string<char>>, true>, std::__1::allocator<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>>> {
        struct unique_ptr<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>*>>> __bucket_list_;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>*>, std::__1::allocator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *>*> {
                struct __hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, void *> *__next_;
            } __first_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__1::__unordered_map_hasher<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, std::__1::hash<std::__1::basic_string<char>>, true>> {
            unsigned long long __first_;
        } __p2_;
        struct __compressed_pair<float, std::__1::__unordered_map_equal<std::__1::basic_string<char>, std::__1::__hash_value_type<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>, std::__1::equal_to<std::__1::basic_string<char>>, true>> {
            float __first_;
        } __p3_;
    } __table_;
};

struct unordered_set<std::__1::basic_string<char>, std::__1::hash<std::__1::basic_string<char>>, std::__1::equal_to<std::__1::basic_string<char>>, std::__1::allocator<std::__1::basic_string<char>>> {
    struct __hash_table<std::__1::basic_string<char>, std::__1::hash<std::__1::basic_string<char>>, std::__1::equal_to<std::__1::basic_string<char>>, std::__1::allocator<std::__1::basic_string<char>>> {
        struct unique_ptr<std::__1::__hash_node<std::__1::basic_string<char>, void *>*[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node<std::__1::basic_string<char>, void *>*>>> __bucket_list_;
        struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *>*>, std::__1::allocator<std::__1::__hash_node<std::__1::basic_string<char>, void *>>> {
            struct __hash_node_base<std::__1::__hash_node<std::__1::basic_string<char>, void *>*> {
                struct __hash_node<std::__1::basic_string<char>, void *> *__next_;
            } __first_;
        } __p1_;
        struct __compressed_pair<unsigned long, std::__1::hash<std::__1::basic_string<char>>> {
            unsigned long long __first_;
        } __p2_;
        struct __compressed_pair<float, std::__1::equal_to<std::__1::basic_string<char>>> {
            float __first_;
        } __p3_;
    } __table_;
};

#pragma mark Typedef'd Structures

typedef struct {
    unsigned int majorVersion:24;
    unsigned int minorVersion:20;
    unsigned int patchVersion:20;
} CDStruct_6df46f26;

#pragma mark -

//
// File: /Applications/Xcode.app/Contents/SharedFrameworks/DADocSetAccess.framework/Versions/A/DADocSetAccess
// UUID: 936108BE-40C9-3AD0-9434-349386D014DB
//
//                           Arch: x86_64
//                Current version: 1.0.0
//          Compatibility version: 1.0.0
//                 Source version: 6032.0.0.0.0
//       Minimum Mac OS X version: 10.9.0
//                    SDK version: 10.10.0
//
// Objective-C Garbage Collection: Unsupported
//
//                       Run path: @loader_path/../../../
//                               = /Applications/Xcode.app/Contents/SharedFrameworks
//

@protocol DSAToken <NSObject>
@property(readonly) DSADocSet *docSet;
@property(readonly, getter=isDeprecated) BOOL deprecated;
@property(readonly, copy) NSString *declaredInFrameworkName;
@property(readonly, copy) NSString *type;
@property(readonly, copy) NSString *scope;
@property(readonly, copy, nonatomic) NSURL *URL;
@property(readonly, copy) NSString *apiLanguage;
@property(readonly, copy) NSString *name;
@property(readonly, copy) NSString *usr;
- (id <DSAToken>)tokenWithFixedUpLanguage:(NSString *)arg1;
- (NSXMLDocument *)XMLDescription;
@end

@protocol NSCoding
- (id)initWithCoder:(NSCoder *)arg1;
- (void)encodeWithCoder:(NSCoder *)arg1;
@end

@protocol NSCopying
- (id)copyWithZone:(struct _NSZone *)arg1;
@end

@protocol NSObject
@property(readonly, copy) NSString *description;
@property(readonly) Class superclass;
@property(readonly) unsigned long long hash;
- (struct _NSZone *)zone;
- (unsigned long long)retainCount;
- (id)autorelease;
- (oneway void)release;
- (id)retain;
- (BOOL)respondsToSelector:(SEL)arg1;
- (BOOL)conformsToProtocol:(Protocol *)arg1;
- (BOOL)isMemberOfClass:(Class)arg1;
- (BOOL)isKindOfClass:(Class)arg1;
- (BOOL)isProxy;
- (id)performSelector:(SEL)arg1 withObject:(id)arg2 withObject:(id)arg3;
- (id)performSelector:(SEL)arg1 withObject:(id)arg2;
- (id)performSelector:(SEL)arg1;
- (id)self;
- (Class)class;
- (BOOL)isEqual:(id)arg1;

@optional
@property(readonly, copy) NSString *debugDescription;
@end

__attribute__((visibility("hidden")))
@interface DSAResultSource : NSObject
{
    NSSortDescriptor *_sortDescriptor;
}

@property(readonly) NSSortDescriptor *sortDescriptor; // @synthesize sortDescriptor=_sortDescriptor;
- (void).cxx_destruct;
- (void)cancel;
- (id)nextResultsInTime:(double)arg1;
- (id)remainingResults;
- (BOOL)hasMoreResults;
- (id)initWithSortDescriptor:(id)arg1;

@end

__attribute__((visibility("hidden")))
@interface DSAArrayResultSource : DSAResultSource
{
    NSArray *_theResults;
}

- (void).cxx_destruct;
- (void)cancel;
- (id)nextResultsInTime:(double)arg1;
- (id)remainingResults;
- (BOOL)hasMoreResults;
- (id)initWithResults:(id)arg1 withSortDescriptor:(id)arg2;

@end

@interface DSADistributionVersion : NSManagedObject
{
    CDStruct_6df46f26 _versionValue;
}

+ (id)assignVersions:(id)arg1 forArchitectures:(id)arg2 maximumVersion:(CDStruct_6df46f26)arg3 inclusive:(BOOL)arg4;
+ (id)architectureNamesForArchitectureFlags:(id)arg1;
+ (id)architectureFlagsForArchitectureNames:(id)arg1;
+ (id)_knownArchitectureFlags;
+ (id)knownArchitectureNames;
- (void)setJointVersionKey:(id)arg1;
- (id)jointVersionKey;
- (id)architectureFlags;
- (CDStruct_6df46f26)versionValue;
- (long long)compare:(id)arg1;

@end

@interface DSADocSet : NSObject
{
    struct __CFBundle *_docSetBundle;
    NSString *_localization;
    BOOL _isLegacy;
    BOOL _isValid;
    int _modelVersion;
    NSURL *_documentsURL;
    NSPersistentStoreCoordinator *_persistentStoreCoordinator;
    NSManagedObjectContext *_managedObjectContext;
    NSMutableDictionary *_indexesByName;
    DSATokenIndex *_mainTokenIndex;
    DSATokenIndex *_backgroundTokenIndex;
    NSManagedObject *_docSetMO;
    DSANode *_rootNode;
    NSArray *_apiLanguageMOs;
    NSDictionary *_nodesByPath;
    NSMutableDictionary *_nodesByID;
    NSArray *_availabilityArchitectures;
    NSMutableDictionary *_nodeByUUID;
    NSObject<OS_dispatch_group> *_tocLoadGroup;
    NSMapTable *_nodeTermLists;
    DSATermManager *_termManager;
    BOOL _searchTermsLoaded;
    DSADocSet_FastTokenCache *_fastTokenCache;
}

+ (BOOL)isTokenDeprecated:(id)arg1;
+ (id)resolvedURL:(id)arg1 forDocSets:(id)arg2 withCompletionBlock:(CDUnknownBlockType)arg3;
+ (id)_resolveAbsoluteFileURL:(id)arg1 forDocSets:(id)arg2 resolvedWithDocSet:(id *)arg3;
+ (id)_resolveRelativeURL:(id)arg1 forDocSets:(id)arg2 resolvedWithDocSet:(id *)arg3;
+ (id)_resolveRemoteURL:(id)arg1 forDocSets:(id)arg2 resolvedWithDocSet:(id *)arg3;
+ (void)cancelTokenSearchForDelegate:(id)arg1 contextInfo:(void *)arg2;
+ (BOOL)searchForTokens:(id)arg1 inDocSets:(id)arg2 withSortDescriptors:(id)arg3 delegate:(id)arg4 contextInfo:(void *)arg5;
+ (void)cancelTextSearchForDelegate:(id)arg1 contextInfo:(void *)arg2;
+ (BOOL)searchForText:(id)arg1 inDocSets:(id)arg2 withMatchType:(unsigned long long)arg3 delegate:(id)arg4 contextInfo:(void *)arg5;
+ (id)docSetForManagedObject:(id)arg1;
+ (int)defaultModelVersion;
+ (int)versionForModel:(id)arg1;
+ (id)modelPathForVersion:(int)arg1;
+ (id)modelForVersion:(int)arg1;
+ (id)_URLForModelInBundle:(struct __CFBundle *)arg1 withLocalization:(id)arg2;
+ (id)_URLForStoreInBundle:(struct __CFBundle *)arg1 withLocalization:(id)arg2;
+ (id)_docSetForCoordinator:(id)arg1;
+ (void)_setDocSet:(id)arg1 forCoordinator:(id)arg2;
@property(retain) DSADocSet_FastTokenCache *fastTokenCache; // @synthesize fastTokenCache=_fastTokenCache;
- (void).cxx_destruct;
- (id)tokenCacheURL;
- (BOOL)hasTokenWithScope:(id)arg1;
- (id)tokensMatchingString:(id)arg1 withMatchType:(unsigned long long)arg2;
- (void)loadTokenCache;
- (void)serializeFastTokenCache:(id)arg1 toPath:(id)arg2;
@property(readonly) BOOL hasTokenCache;
- (void)buildTokenCache;
- (id)allNodes;
- (id)allTokens;
- (id)nodeForURL:(id)arg1;
- (id)bookNodeForURL:(id)arg1;
- (id)_nodeForLookupString:(id)arg1 URLisFileURL:(BOOL)arg2 URLPointsIntoDocSet:(BOOL)arg3;
- (void)_setupNodesByPath;
- (void)_saveCachedNodePaths;
- (void)_loadCachedNodePaths;
- (BOOL)_shouldLoadNodePathCache:(id)arg1;
- (id)_pathForCachedNodePaths;
- (id)availabilityArchitectures;
- (id)apiLanguages;
- (id)_apiLanguageMOs;
- (id)releaseNoteInformation;
- (id)nodesWithDocumentType:(unsigned long long)arg1;
- (id)nodes;
- (id)nodesWithUUIDPattern:(id)arg1;
- (id)nodeWithUUID:(id)arg1;
- (id)searchTermsForNodes:(id)arg1;
- (id)searchTermsForNodeID:(id)arg1 waitForCache:(BOOL)arg2;
- (id)nodesWithIDNumbers:(id)arg1;
- (id)nodeWithIDNumber:(id)arg1;
- (id)nodeWithID:(long long)arg1;
- (void)_setObjectIDSForNodes:(id)arg1;
- (void)_setObjectID:(id)arg1 forNodeID:(id)arg2;
- (id)_objectIDForNodeID:(id)arg1;
- (void)_startLoadingTOCInfo;
- (id)termManager;
- (id)sharedBackgroundAPIIndex;
- (id)sharedAPIIndex;
- (id)apiIndexForUpdating:(BOOL)arg1;
- (id)fullTextIndexForUpdating:(BOOL)arg1;
- (id)_indexNamed:(id)arg1 forUpdating:(BOOL)arg2;
- (id)textIndexURL;
- (double)offsetIntervalForUpdateCheck;
@property(readonly) BOOL requiresUpdateForContent;
- (id)certificateIssuer;
- (id)certificateSigner;
- (id)fallbackURLs;
- (id)fallbackURL;
- (id)documentsURL;
- (id)docSetURL;
- (CDStruct_6df46f26)maximumSupportedXcodeVersion;
- (CDStruct_6df46f26)minimumSupportedXcodeVersion;
- (CDStruct_6df46f26)platformVersion;
- (id)platformFamily;
- (CDStruct_6df46f26)configurationVersion;
- (long long)compare:(id)arg1;
- (CDStruct_6df46f26)version;
- (id)identifier;
- (id)localizedName;
- (id)feedURL;
- (id)localizedFeedName;
@property(readonly) NSString *publisherIdentifier;
@property(readonly) NSString *localizedPublisherName;
@property(readonly) NSString *localizedDescription;
- (BOOL)isLegacyPackage;
- (id)nodeAtNamedPath:(id)arg1;
- (id)rootNode;
- (id)tokenFileURLs;
- (id)localization;
- (id)_objectForInfoKey:(id)arg1;
- (void)_resetBundle;
- (id)bundle;
- (void)_dump;
- (id)_dumpStr;
- (id)description;
- (void)deleteDiskCaches;
- (void)dealloc;
- (void)invalidate;
@property(readonly) BOOL isValid;
- (id)initWithDocRootDirectory:(id)arg1 withXML:(id)arg2;
- (id)initWithURL:(id)arg1 error:(id *)arg2;
- (id)initWithBundle:(struct __CFBundle *)arg1 withPersistentStoreURL:(id)arg2 modelVersion:(int)arg3 forLocalization:(id)arg4 error:(id *)arg5;
- (id)initWithDocRootDirectory:(id)arg1 forLocalization:(id)arg2 error:(id *)arg3;
- (id)initWithBundle:(struct __CFBundle *)arg1 withXML:(id)arg2 withPersistentStoreCoordinator:(id)arg3 modelVersion:(int)arg4 forLocalization:(id)arg5 error:(id *)arg6;
- (id)lookupTokensWithUSR:(id)arg1;
@property(readonly) BOOL supportsUSRLookup;
- (id)searchForTokens:(id)arg1 inNodes:(id)arg2;
- (BOOL)containsTokens:(id)arg1;
- (void)cancelTextSearchForDelegate:(id)arg1 contextInfo:(void *)arg2;
- (BOOL)searchForText:(id)arg1 inNodes:(id)arg2 withMatchType:(unsigned long long)arg3 delegate:(id)arg4 contextInfo:(void *)arg5;
- (id)searchForText:(id)arg1 inNodes:(id)arg2 withMatchType:(unsigned long long)arg3;
- (int)modelVersion;
- (BOOL)saveChanges:(id *)arg1;
- (BOOL)migrateDataToURL:(id)arg1 copyModel:(BOOL)arg2 error:(id *)arg3;
- (void)_writeCachedNodeInfo;
- (void)_removePersistentStores;
- (id)persistentStoreURL;
- (id)managedObjectContext;
- (id)persistentStoreCoordinator;
- (id)managedObjectModel;
- (id)urlForNode:(id)arg1 localizingPath:(BOOL)arg2;
- (id)localizedPathsForNode:(id)arg1 inBundle:(id)arg2;
- (id)_localizedPathForNode:(id)arg1 inBundle:(id)arg2 forLocalization:(id)arg3;
- (id)_localizedPathInBundle:(id)arg1 forFile:(id)arg2 forLocalization:(id)arg3;
- (id)tokenXMLForToken:(id)arg1;
- (id)urlForTokenXML:(id)arg1;
- (id)urlForToken:(id)arg1;
- (id)urlForNode:(id)arg1;

@end

__attribute__((visibility("hidden")))
@interface DSADocSet_FastTokenCache : NSObject
{
    struct unordered_multimap<std::__1::basic_string<char>, const tokenPayload, std::__1::hash<std::__1::basic_string<char>>, std::__1::equal_to<std::__1::basic_string<char>>, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, const tokenPayload>>> tokenCache;
    struct unordered_set<std::__1::basic_string<char>, std::__1::hash<std::__1::basic_string<char>>, std::__1::equal_to<std::__1::basic_string<char>>, std::__1::allocator<std::__1::basic_string<char>>> tokenNames1;
    struct unordered_set<std::__1::basic_string<char>, std::__1::hash<std::__1::basic_string<char>>, std::__1::equal_to<std::__1::basic_string<char>>, std::__1::allocator<std::__1::basic_string<char>>> tokenNames2;
    struct set<std::__1::basic_string<char>, std::__1::less<std::__1::basic_string<char>>, std::__1::allocator<std::__1::basic_string<char>>> scopes;
    struct unordered_multimap<std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>, std::__1::hash<std::__1::basic_string<char>>, std::__1::equal_to<std::__1::basic_string<char>>, std::__1::allocator<std::__1::pair<const std::__1::basic_string<char>, std::__1::__hash_map_const_iterator<std::__1::__hash_const_iterator<std::__1::__hash_node<std::__1::__hash_value_type<std::__1::basic_string<char>, const tokenPayload>, void *>*>>>>> tokenUSRIndex;
}

- (id).cxx_construct;
- (void).cxx_destruct;
- (id)tokensMatchingUSR:(id)arg1 docSet:(id)arg2;
- (BOOL)docSet:(id)arg1 hasTokenWithScope:(id)arg2;
- (id)tokensMatchingString:(id)arg1 withMatchType:(unsigned long long)arg2 docSet:(id)arg3;
- (void)createCache:(id)arg1;

@end

@interface DSAFastToken : NSObject <DSAToken, NSCoding>
{
    NSXMLDocument *_XMLDescription;
    BOOL deprecated;
    NSString *usr;
    NSString *name;
    NSString *apiLanguage;
    NSString *relativeURL;
    NSString *scope;
    NSString *type;
    NSString *declaredInFrameworkName;
    DSADocSet *docSet;
}

+ (id)fastTokenWithUSR:(id)arg1 name:(id)arg2 language:(id)arg3 relativeURL:(id)arg4 scope:(id)arg5 type:(id)arg6 declaredInFrameworkName:(id)arg7 deprecated:(BOOL)arg8 docSet:(id)arg9;
@property(retain) DSADocSet *docSet; // @synthesize docSet;
@property(getter=isDeprecated) BOOL deprecated; // @synthesize deprecated;
@property(copy) NSString *declaredInFrameworkName; // @synthesize declaredInFrameworkName;
@property(copy) NSString *type; // @synthesize type;
@property(copy) NSString *scope; // @synthesize scope;
@property(copy) NSString *relativeURL; // @synthesize relativeURL;
@property(copy) NSString *apiLanguage; // @synthesize apiLanguage;
@property(copy) NSString *name; // @synthesize name;
@property(copy) NSString *usr; // @synthesize usr;
- (void).cxx_destruct;
- (id)tokenWithFixedUpLanguage:(id)arg1;
- (id)XMLDescription;
@property(readonly, copy, nonatomic) NSURL *URL;
- (id)availabilityInformationAsOfDistributionVersion:(CDStruct_6df46f26)arg1 forArchitectures:(id)arg2;
- (id)abstract;
- (id)fastTokenWithLanguage:(id)arg1;
- (id)initWithCoder:(id)arg1;
- (void)encodeWithCoder:(id)arg1;
- (id)copy;
@property(readonly) unsigned long long hash;
- (BOOL)isEqual:(id)arg1;
@property(readonly, copy) NSString *description;
- (id)valueForDeclaredInFrameworkName;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly) Class superclass;

@end

__attribute__((visibility("hidden")))
@interface DSAMultipleResultSource : DSAResultSource
{
    NSArray *_theSources;
    NSMutableArray *_remainingSources;
    NSMutableArray *_sourceCaches;
    unsigned long long *_unsignedMemory;
    NSString *_sortKey;
    NSSortDescriptor *_sortDescriptorForValue;
    unsigned long long _numberOfCompares;
}

@property unsigned long long numberOfCompares; // @synthesize numberOfCompares=_numberOfCompares;
- (void).cxx_destruct;
- (long long)compareObject:(id)arg1 toObject:(id)arg2;
- (struct _NSRange)rangeFromArray:(id)arg1 aboveValue:(id)arg2 includingExactMatches:(BOOL)arg3 startingIndex:(unsigned long long)arg4 nextFailedValue:(id *)arg5;
- (id)mergeForTime:(double)arg1;
- (id)_sortValueForObject:(id)arg1;
- (id)nextResultsInTime:(double)arg1;
- (id)remainingResults;
- (void)_sourceExpendedAtIndex:(unsigned long long)arg1;
- (BOOL)hasMoreResults;
- (void)cancel;
- (void)dealloc;
- (id)initWithSources:(id)arg1 withSortDescriptor:(id)arg2;

@end

@interface DSANode : NSManagedObject
{
    unsigned int _isInvalidated:1;
    unsigned int _rootNodeStateInitialized:1;
    unsigned int _isRootNode:1;
}

+ (struct __CFSet *)copyNodeIDsForNodes:(id)arg1;
+ (id)nodeTypes;
- (BOOL)_isCurrentOrVersionAfter:(int)arg1;
- (id)URL;
- (id)apiLanguagesInHierarchy;
- (id)languages;
- (id)searchableNodesInHierarchy;
- (id)nodesInHierarchy;
- (id)_nodesInHierarchySearchable:(BOOL)arg1;
- (void)_findNodes:(id)arg1 inHierarchy:(id)arg2 areSearchable:(BOOL)arg3;
- (id)unsearchableChildren;
- (id)searchableChildren;
- (id)_subnodesWithSearchability:(BOOL)arg1;
- (id)namedPaths;
- (id)_namesForPath:(id)arg1;
- (id)primaryNodePath;
- (id)nodePaths;
- (id)_nodePathsWithExistingDescendants:(id)arg1;
- (id)childWithName:(id)arg1;
- (id)children;
- (id)primaryParent;
- (id)_primaryParentUsingNodePaths:(id)arg1;
- (id)parents;
- (id)searchTerms;
- (id)_cachedTermList;
- (id)urlsForDownloadableFilesByType;
- (id)_downloadableFiles;
- (id)relatedNodes;
- (id)docSet;
- (BOOL)isRootNode;
- (void)setRootNode:(BOOL)arg1;
- (long long)childCount;
- (unsigned long long)domain;
@property(readonly) unsigned long long documentType;
@property(readonly) DSANode *documentTypeNode;
- (unsigned long long)type;
- (id)urlString;
- (id)anchor;
- (id)file;
- (id)path;
- (id)nodeURL;
- (id)name;
- (BOOL)isSearchable;
- (long long)nodeID;
- (void)invalidate;
- (void)dealloc;
- (id)_dumpStr;

// Remaining properties
@property(readonly) NSNumber *installDomain; // @dynamic installDomain;
@property(readonly) NSString *kAnchor; // @dynamic kAnchor;
@property(readonly) NSString *kFileName; // @dynamic kFileName;
@property(readonly) NSNumber *kID; // @dynamic kID;
@property(readonly) NSString *kName; // @dynamic kName;
@property(readonly) id kNodeType; // @dynamic kNodeType;
@property(readonly) NSString *kPath; // @dynamic kPath;
@property(readonly) NSNumber *kSubnodeCount; // @dynamic kSubnodeCount;
@property(readonly) NSString *kURL; // @dynamic kURL;
@property(readonly) NSSet *orderedSubnodes; // @dynamic orderedSubnodes;

@end

@interface DSATextSearchResult : NSObject <NSCopying>
{
    float _resultRelevance;
    float _childrenRelevance;
    NSArray *_children;
}

+ (id)buildResultTree:(id)arg1;
+ (float)maximumRelevanceForResults:(id)arg1;
@property(copy) NSArray *children; // @synthesize children=_children;
@property float childrenRelevance; // @synthesize childrenRelevance=_childrenRelevance;
@property float resultRelevance; // @synthesize resultRelevance=_resultRelevance;
- (void).cxx_destruct;
- (void)_calculateChildrenRelevance;
- (id)flattenTree;
- (id)description;
- (id)iterativeDescriptionWithIndent:(id)arg1;
- (id)copyWithZone:(struct _NSZone *)arg1;
@property(readonly, copy) NSString *title;
- (id)docSet;
- (id)parentNode;
- (id)nearestNodeID;
- (id)node;
- (id)URL;
@property(readonly) float relevance;
@property(readonly) BOOL isTitleMatch;

@end

__attribute__((visibility("hidden")))
@interface DSANodeSearchResult : DSATextSearchResult
{
    id _node_or_ID;
    DSADocSet *_docSet;
    BOOL _isTitleMatch;
}

- (void).cxx_destruct;
- (BOOL)isTitleMatch;
- (id)title;
- (id)docSet;
- (id)nearestNodeID;
- (id)parentNode;
- (id)node;
- (id)URL;
- (id)copyWithZone:(struct _NSZone *)arg1;
- (id)initWithNode:(id)arg1 docSet:(id)arg2 relevance:(float)arg3 isTitleMatch:(BOOL)arg4;

@end

__attribute__((visibility("hidden")))
@interface DSANodeURL : NSManagedObject
{
}

+ (id)localPathForURLString:(id)arg1 path:(id)arg2 fileName:(id)arg3 anchor:(id)arg4 type:(unsigned long long)arg5;
+ (id)nodeURLForLocalPath:(id)arg1 inContext:(id)arg2;
+ (int)checksumForLocalPath:(id)arg1;
- (id)localPath;
- (void)updateChecksum;

// Remaining properties
@property(retain, nonatomic) NSString *anchor; // @dynamic anchor;
@property(retain, nonatomic) NSString *baseURL; // @dynamic baseURL;
@property(retain, nonatomic) NSNumber *checksum; // @dynamic checksum;
@property(retain, nonatomic) NSString *fileName; // @dynamic fileName;
@property(retain, nonatomic) DSANode *node; // @dynamic node;
@property(retain, nonatomic) NSString *path; // @dynamic path;

@end

__attribute__((visibility("hidden")))
@interface DSAQueuedTextSearch : NSObject
{
    NSString *_query;
    unsigned long long _matchType;
    NSArray *_docSets;
    NSArray *_nodes;
    id _delegate;
    void *_contextInfo;
    BOOL _useSingularDelegateMethod;
}

@property BOOL useSingularDelegateMethod; // @synthesize useSingularDelegateMethod=_useSingularDelegateMethod;
@property(readonly) void *contextInfo; // @synthesize contextInfo=_contextInfo;
@property(readonly) id delegate; // @synthesize delegate=_delegate;
@property(readonly) NSArray *nodes; // @synthesize nodes=_nodes;
@property(readonly) NSArray *docSets; // @synthesize docSets=_docSets;
@property(readonly) unsigned long long matchType; // @synthesize matchType=_matchType;
@property(readonly) NSString *query; // @synthesize query=_query;
- (void).cxx_destruct;
- (id)initWithQuery:(id)arg1 matchType:(unsigned long long)arg2 docSets:(id)arg3 nodes:(id)arg4 delegate:(id)arg5 contextInfo:(void *)arg6;

@end

__attribute__((visibility("hidden")))
@interface DSAQueuedTextSearchResults : NSObject
{
    DSADocSet *_docSet;
    NSArray *_fullTextResults;
    NSArray *_nodeTextResults;
    float _maximumFullTextRelevance;
}

@property float maximumFullTextRelevance; // @synthesize maximumFullTextRelevance=_maximumFullTextRelevance;
@property(retain) NSArray *nodeTextResults; // @synthesize nodeTextResults=_nodeTextResults;
@property(retain) NSArray *fullTextResults; // @synthesize fullTextResults=_fullTextResults;
- (void).cxx_destruct;
- (void)prefetchNodes;
- (id)mergedResults;
- (BOOL)isComplete;
- (id)initForDocSet:(id)arg1;

@end

__attribute__((visibility("hidden")))
@interface DSASearchKitSearchResult : DSATextSearchResult
{
    DSATextIndex *_index;
    unsigned long long _skID;
    unsigned long long _docID;
    unsigned long long _rootID;
    NSString *_path;
    NSString *_title;
}

+ (id)searchResultWithPath:(id)arg1 searchResultID:(unsigned long long)arg2 documentID:(unsigned long long)arg3 docRootID:(unsigned long long)arg4 relevance:(float)arg5 fromIndex:(id)arg6;
- (void).cxx_destruct;
- (id)title;
- (id)nearestNodeID;
- (id)parentNode;
- (id)node;
- (id)URL;
- (id)path;
- (id)docSet;
- (id)index;
- (BOOL)matchesExactNode;
- (id)copyWithZone:(struct _NSZone *)arg1;
- (id)initWithPath:(id)arg1 searchResultID:(unsigned long long)arg2 documentID:(unsigned long long)arg3 docRootID:(unsigned long long)arg4 relevance:(float)arg5 fromIndex:(id)arg6;

@end

__attribute__((visibility("hidden")))
@interface DSATermMatch : NSObject
{
}

+ (id)termMatchForTermMatches:(id)arg1;
+ (id)termMatchForTermID:(unsigned int)arg1 withBaseScore:(float)arg2;
- (float)scoreForTermID:(unsigned int)arg1;
- (float *)scores;
- (unsigned int *)termIDs;
- (unsigned long long)count;

@end

__attribute__((visibility("hidden")))
@interface DSATermGroupMatch : DSATermMatch
{
    unsigned int *_termIDs;
    float *_scores;
    unsigned long long _numberOfTerms;
}

- (float)scoreForTermID:(unsigned int)arg1;
- (unsigned long long)count;
- (id)description;
- (void)dealloc;
- (id)initForTermMatches:(id)arg1;

@end

__attribute__((visibility("hidden")))
@interface DSATermList : NSObject
{
    unsigned int *_termIDs;
    unsigned int _numberOfTerms;
}

- (BOOL)isEqual:(id)arg1;
- (unsigned int *)termIDs;
- (unsigned long long)count;
- (id)data;
- (id)description;
- (void)dealloc;
- (id)initWithData:(id)arg1;
- (id)initWithWordLists:(id)arg1 usingManager:(id)arg2;

@end

__attribute__((visibility("hidden")))
@interface DSATermManager : NSObject
{
    NSMapTable *_terms;
    unsigned int _nextID;
}

+ (id)termsFromString:(id)arg1;
+ (id)termsFromQuery:(id)arg1;
+ (id)_termsFromString:(id)arg1 usingWordBoundaries:(id)arg2;
- (void).cxx_destruct;
- (id)termMatchForSubstring:(id)arg1 style:(unsigned long long)arg2;
- (unsigned int)addTerm:(id)arg1;
- (unsigned int)idForTerm:(id)arg1;
- (id)orderedTerms;
- (id)initWithTerms:(id)arg1;

@end

__attribute__((visibility("hidden")))
@interface DSATermQuery : NSObject
{
    NSArray *_termMatchList;
}

- (void).cxx_destruct;
- (float)scoreForTermList:(id)arg1 isTitleMatch:(char *)arg2;
- (BOOL)failsAllTests;
- (id)initWithSearchString:(id)arg1 withMatchType:(unsigned long long)arg2 usingManager:(id)arg3;

@end

__attribute__((visibility("hidden")))
@interface DSATermSingleMatch : DSATermMatch
{
    unsigned int _termID;
    float _score;
}

- (float)scoreForTermID:(unsigned int)arg1;
- (float *)scores;
- (unsigned int *)termIDs;
- (unsigned long long)count;
- (id)description;
- (id)initForTermID:(unsigned int)arg1 withBaseScore:(float)arg2;

@end

@interface DocSetIndex : NSObject
{
    struct __SKIndex *_searchIndex;
    NSMutableData *_data;
}

+ (void)loadDefaultExtractorPlugIns;
- (void).cxx_destruct;
- (BOOL)addContentsOfDirectoryAtPath:(id)arg1 withRecursion:(BOOL)arg2;
- (BOOL)addDocumentAtPath:(id)arg1;
- (struct __SKIndex *)indexRef;
- (unsigned long long)termIDForTermString:(id)arg1;
- (id)termStringForTermID:(unsigned long long)arg1;
- (id)documentIDArrayForTermID:(unsigned long long)arg1;
- (unsigned long long)documentCountForTermID:(unsigned long long)arg1;
- (unsigned long long)maxTermID;
- (unsigned long long)frequencyForTermID:(unsigned long long)arg1 inDocumentID:(long long)arg2;
- (id)termIDArrayForDocumentID:(long long)arg1;
- (unsigned long long)termCountForDocumentID:(long long)arg1;
- (long long)maxDocumentID;
- (id)iteratorForParentDocument:(id)arg1;
- (BOOL)moveDocument:(id)arg1 toNewParentDocument:(id)arg2;
- (BOOL)renameDocument:(id)arg1 withName:(id)arg2;
- (id)documentForDocumentID:(long long)arg1;
- (long long)IDForDocument:(id)arg1;
- (int)stateForDocument:(id)arg1;
- (void)setProperties:(id)arg1 forDocument:(id)arg2;
- (id)propertiesForDocument:(id)arg1;
- (BOOL)removeDocument:(id)arg1;
- (BOOL)addDocument:(id)arg1 withMIMETypeHint:(id)arg2 canReplace:(BOOL)arg3;
- (BOOL)addDocument:(id)arg1 withText:(id)arg2 canReplace:(BOOL)arg3;
- (void)_loadDefaultExtractorPluginsIfNeeded;
- (unsigned long long)documentCount;
- (id)analysisProperties;
- (int)indexType;
- (BOOL)compact;
- (void)setMaximumBytesBeforeFlush:(unsigned long long)arg1;
- (unsigned long long)maximumBytesBeforeFlush;
- (BOOL)flush;
- (void)invalidate;
- (void)dealloc;
- (id)initExistingIndexWithMutableData:(id)arg1 indexName:(id)arg2;
- (id)initExistingReadOnlyIndexWithData:(id)arg1 indexName:(id)arg2;
- (id)initWithMutableData:(id)arg1 indexName:(id)arg2 indexType:(int)arg3 analysisProperties:(id)arg4;
- (id)initExistingIndexWithURL:(id)arg1 indexName:(id)arg2 writeAccess:(BOOL)arg3;
- (id)initWithURL:(id)arg1 indexName:(id)arg2 indexType:(int)arg3 analysisProperties:(id)arg4;
- (id)initWithSKIndexRef:(struct __SKIndex *)arg1;

@end

@interface DSATextIndex : DocSetIndex
{
    DSADocSet *_docSet;
    NSMutableDictionary *_rootDocumentForPath;
    struct __CFDictionary *_rootIDURLs;
    struct __CFDictionary *_rootIDTypes;
    struct __CFDictionary *_rootTypeIDs;
    struct __CFDictionary *_skIDToDSID;
    BOOL _mappingIsDirty;
}

- (void).cxx_destruct;
- (long long)documentIDForSKID:(long long)arg1;
- (BOOL)indexSubDirectory:(id)arg1 forDocument:(id)arg2 atPath:(id)arg3 onlyTypes:(id)arg4;
- (BOOL)indexDirectoryForDocument:(id)arg1 atPath:(id)arg2 onlyTypes:(id)arg3;
- (BOOL)_indexFile:(id)arg1 belowParent:(id)arg2 atPath:(id)arg3 withDefaultTitle:(id)arg4;
- (BOOL)indexFile:(id)arg1 belowParent:(id)arg2 atPath:(id)arg3;
- (void)indexDocSetNode:(id)arg1 atPath:(id)arg2 isFolder:(BOOL)arg3 inRootPath:(id)arg4;
- (void)indexDocSetNode:(id)arg1 atPath:(id)arg2 usingLocalizedPathInfo:(id)arg3 inRootPath:(id)arg4;
- (void)_indexDocSetNode:(id)arg1 atPath:(id)arg2 isFolder:(BOOL)arg3 localizedPathInfo:(id)arg4 inRootPath:(id)arg5;
- (void)_removeDocumentForDocID:(long long)arg1;
- (id)docSet;
- (void)setDocSet:(id)arg1;
- (long long)fallbackRootID;
- (id)fallbackRootDocument;
- (void)setFallbackRootPath:(id)arg1;
- (long long)defaultRootID;
- (id)defaultRootDocument;
- (void)setDefaultRootPath:(id)arg1;
- (void)setRootURL:(id)arg1 forPath:(id)arg2 ofType:(id)arg3;
- (id)rootDocumentForPath:(id)arg1;
- (id)rootDocumentForType:(id)arg1;
- (id)urlForRootID:(long long)arg1;
- (long long)rootIDForType:(id)arg1;
- (id)rootTypeForID:(long long)arg1;
- (void)_loadDocRoots;
- (id)_standardizedRootURL:(id)arg1;
- (void)_loadMappingsFromProperties:(id)arg1;
- (BOOL)flush;
- (void)invalidate;
- (void)dealloc;

@end

@interface DSATextSearch : NSObject
{
    NSString *_query;
    unsigned long long _maxMatches;
    float _maxScore;
    DSATextIndex *_indexToSearch;
    unsigned int _options;
    DocSetIndexSearch *_search;
    long long *_documentIDs;
    const struct __CFString **_documentNames;
    float *_scores;
    struct __CFSet *_nodeIDFilter;
}

- (void).cxx_destruct;
- (id)searchResultsInTime:(double)arg1 minimumScore:(float)arg2;
- (id)_getResults:(unsigned long long)arg1;
- (unsigned long long)_filterResults:(unsigned long long)arg1 withMinimumScore:(float)arg2;
- (BOOL)isFinished;
- (float)maximumRelevanceForResults;
- (void)cancel;
- (void)filterResultsToDocIDs:(struct __CFSet *)arg1;
- (void)setNodeFilter:(id)arg1;
- (unsigned int)options;
- (void)setOptions:(unsigned int)arg1;
- (id)query;
- (void)setQuery:(id)arg1;
- (id)index;
- (void)invalidate;
- (void)dealloc;
- (id)initWithFilterableIndex:(id)arg1 query:(id)arg2 options:(unsigned int)arg3;

@end

__attribute__((visibility("hidden")))
@interface DSATextSearchQueue : NSObject
{
    NSMutableDictionary *_searchForDocSet;
    NSMutableArray *_searchQueue;
    NSMutableArray *_searchResults;
    BOOL _currentSearchCanceled;
}

+ (id)_mungeQueryString:(id)arg1 forMatchType:(unsigned long long)arg2;
+ (BOOL)_looksLikeSearchKitQuery:(id)arg1;
+ (id)sharedQueue;
- (void).cxx_destruct;
- (id)searchForText:(id)arg1 inNodes:(id)arg2 inDocSet:(id)arg3 withMatchType:(unsigned long long)arg4;
- (id)_searchTermLists:(id)arg1 inDocSet:(id)arg2 forQuery:(id)arg3 withMatchType:(unsigned long long)arg4 allowCancel:(BOOL)arg5;
- (id)_searchFullTextIndex:(id)arg1;
- (void)invalidateSearchesOfDocSet:(id)arg1;
- (void)cancelSearchWithDelegate:(id)arg1 contextInfo:(void *)arg2;
- (BOOL)addQueuedQuery:(id)arg1 inDocSets:(id)arg2 withMatchType:(unsigned long long)arg3 delegate:(id)arg4 contextInfo:(void *)arg5;
- (BOOL)addQueuedQuery:(id)arg1 inNodes:(id)arg2 inDocSet:(id)arg3 withMatchType:(unsigned long long)arg4 delegate:(id)arg5 contextInfo:(void *)arg6;
- (BOOL)_addQueuedQuery:(id)arg1 inNodes:(id)arg2 inDocSets:(id)arg3 withMatchType:(unsigned long long)arg4 usingSingularDelegateMethod:(BOOL)arg5 delegate:(id)arg6 contextInfo:(void *)arg7;
- (void)processResults:(id)arg1;
- (void)startSearch;
- (void)removeSearchObjectForDocSet:(id)arg1;
- (id)searchObjectForDocSet:(id)arg1;
- (id)init;

@end

@interface DSAToken : NSManagedObject <DSAToken>
{
}

+ (id)descriptionForIDInformation:(id)arg1;
+ (id)tokenTypeCategoryForKey:(id)arg1 forLocalization:(id)arg2;
+ (id)standardizedLanguageForKey:(id)arg1;
- (id)URLString;
@property(readonly, copy, nonatomic) NSURL *URL;
@property(readonly, copy) NSString *description;
- (id)tokenTypeCategory;
- (id)deprecationVersionStatementAsOfVersion:(id)arg1;
- (id)deprecationVersionStatement;
- (id)availabilityVersionStatement;
- (id)availabilityInformationAsOfDistributionVersion:(CDStruct_6df46f26)arg1 forArchitectures:(id)arg2;
- (id)_lastRemovalStringForArchitectures:(id)arg1 fromRemovedVersions:(id)arg2;
- (id)mergedRelatedTokens;
- (id)relatedTokens;
- (id)distributionName;
- (id)removedAfterVersionString;
- (id)removedAfterVersions;
- (id)removedAfterVersion;
- (void)setRemovedAfterVersions:(id)arg1;
- (void)setRemovedAfterVersion:(id)arg1;
- (id)deprecatedInVersionString;
- (id)deprecatedInVersions;
- (id)deprecatedInVersion;
- (void)setDeprecatedInVersions:(id)arg1;
- (void)setDeprecatedInVersion:(id)arg1;
- (id)introducedInVersionString;
- (id)introducedInVersions;
- (id)introducedInVersion;
- (void)setIntroducedInVersions:(id)arg1;
- (void)setIntroducedInVersion:(id)arg1;
- (id)adoptedProtocols;
- (id)superclasses;
- (id)anchor;
- (void)setAnchor:(id)arg1;
- (id)filePath;
- (id)file;
- (void)setFile:(id)arg1;
- (id)relatedDocuments;
- (void)setRelatedDocuments:(id)arg1;
- (id)relatedSampleCode;
- (void)setRelatedSampleCode:(id)arg1;
- (id)relatedGroups;
- (void)setRelatedGroups:(id)arg1;
- (id)seeAlsoRelatedTokens;
- (void)setSeeAlsoRelatedTokens:(id)arg1;
- (id)tokenWithFixedUpLanguage:(id)arg1;
- (id)XMLDescription;
- (id)deprecationSummaryAsHTML;
- (id)deprecationSummary;
- (void)setDeprecationSummary:(id)arg1;
@property(readonly, copy) NSString *declaredInFrameworkName;
- (id)declaredInHeaderURL;
- (id)declaredIn;
- (void)setDeclaredIn:(id)arg1;
- (id)returnValueAbstractAsHTML;
- (id)returnValueInfo;
- (void)setReturnValueInfo:(id)arg1;
- (id)parametersInfo;
- (void)setParametersInfo:(id)arg1;
- (id)declarationAsHTML;
- (id)declaration;
- (void)setDeclaration:(id)arg1;
- (id)abstractAsHTML;
- (id)abstract;
- (void)setAbstract:(id)arg1;
- (id)parentNode;
- (void)setParentNode:(id)arg1;
- (id)tokenName;
- (void)setTokenName:(id)arg1;
@property(readonly, copy) NSString *scope;
@property(readonly, copy) NSString *type;
@property(readonly, copy) NSString *apiLanguage;
@property(readonly, copy) NSString *name;
@property(readonly, copy) NSString *usr;
- (id)_metainfoCreatingIfMissing:(BOOL)arg1;
@property(readonly) DSADocSet *docSet;
@property(readonly, getter=isDeprecated) BOOL deprecated;

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

@interface DSATokenIndex : NSObject
{
    DSADocSet *_docSet;
    NSManagedObjectContext *_moc;
    BOOL _readOnly;
    NSNumber *_tokensHaveParents;
    unsigned long long _maxSortOrder;
    NSMutableDictionary *_fullNameLookup;
    NSMutableDictionary *_languageMOs;
    NSMutableDictionary *_tokenTypeMOs;
    NSMutableDictionary *_distributionMOs;
    NSMutableDictionary *_containerMOs;
    NSMutableDictionary *_headerMOs;
}

+ (id)idInformationForIDString:(id)arg1;
+ (id)idInformationForIDXMLElement:(id)arg1;
- (void).cxx_destruct;
- (id)lowercaseUTF8ByteForString:(id)arg1;
- (id)createRelatedTokenGroupNamed:(id)arg1 withTokens:(id)arg2;
- (id)createTokenWithIDInformation:(id)arg1;
- (id)createTokenWithUSR:(id)arg1 iDInformation:(id)arg2 displayName:(id)arg3;
- (id)managedObjectsForContainer;
- (id)managedObjectsForTokenType;
- (id)managedObjectsForLanguage;
- (long long)languageCount;
- (id)managedObjectForContainer:(id)arg1 creatingIfMissing:(BOOL)arg2;
- (id)managedObjectForDistribution:(id)arg1 version:(id)arg2 architecture:(int)arg3 creatingIfMissing:(BOOL)arg4;
- (id)managedObjectForTokenType:(id)arg1 creatingIfMissing:(BOOL)arg2;
- (id)managedObjectForFilePath:(id)arg1 creatingIfMissing:(BOOL)arg2;
- (id)managedObjectForHeader:(id)arg1 framework:(id)arg2 creatingIfMissing:(BOOL)arg3;
- (id)managedObjectForLanguage:(id)arg1 creatingIfMissing:(BOOL)arg2;
- (id)_managedObjectWithName:(id)arg1 forEntity:(id)arg2 withKeyName:(id)arg3 creatingIfMissing:(BOOL)arg4 inMutableDictionary:(id *)arg5;
- (id)_mutableDictionaryForEntity:(id)arg1 forKey:(id)arg2;
- (id)idInformationForIDString:(id)arg1;
- (id)idInformationForIDXMLElement:(id)arg1;
- (id)nodeWithID:(long long)arg1;
- (BOOL)saveChanges:(id *)arg1;
- (BOOL)deleteTokenReferences;
- (void)_resetTableForEntityNamed:(id)arg1;
- (unsigned long long)maxSortOrder;
- (BOOL)tokensHaveParents;
- (void)executeBackgroundBlock:(CDUnknownBlockType)arg1;
- (void)setReadOnly:(BOOL)arg1;
- (BOOL)readOnly;
- (id)managedObjectContext;
- (id)docSet;
- (id)initWithDocSet:(id)arg1 forBackgroundQueries:(BOOL)arg2;
- (id)lookupTokensWithUSR:(id)arg1;
- (id)tokensMatchingCriteria:(id)arg1 inNodes:(id)arg2 error:(id *)arg3;
- (id)tokensMatchingCriteria:(id)arg1 error:(id *)arg2;
- (BOOL)containsTokens:(id)arg1;
- (unsigned long long)countTokensMatchingPredicate:(id)arg1 error:(id *)arg2;
- (id)tokenIDsMatchingPredicate:(id)arg1 withSortDescriptors:(id)arg2 error:(id *)arg3;
- (id)tokenIDsMatchingPredicate:(id)arg1 withSortDescriptors:(id)arg2 fetchLimit:(unsigned long long)arg3 error:(id *)arg4;
- (id)tokensMatchingPredicate:(id)arg1 withSortDescriptors:(id)arg2 error:(id *)arg3;
- (id)_tokensMatchingPredicate:(id)arg1 withSortDescriptors:(id)arg2 returningType:(unsigned long long)arg3 fetchLimit:(unsigned long long)arg4 error:(id *)arg5;
- (id)predicateForQuery:(id)arg1;
- (id)_predicateForLanguageCriterion:(id)arg1;

@end

__attribute__((visibility("hidden")))
@interface DSATokenSearchManager : NSObject
{
    NSMutableArray *_searchQueue;
    unsigned int _nextQueuePosition;
    NSTimer *_fetchTimer;
}

+ (id)sharedManager;
- (void).cxx_destruct;
- (void)doNextFetch;
- (BOOL)startTokenSearch:(id)arg1 inDocSets:(id)arg2 withSortDescriptors:(id)arg3 delegate:(id)arg4 contextInfo:(void *)arg5;
- (void)cancelSearchWithDelegate:(id)arg1 contextInfo:(void *)arg2;
- (id)init;

@end

__attribute__((visibility("hidden")))
@interface DSATokenSource : DSAResultSource
{
    DSADocSet *_docSet;
    NSDictionary *_query;
    NSPredicate *_predicate;
    NSArray *_rationalizedSortDescriptors;
    int _batchType;
    BOOL _ascending;
    NSMutableDictionary *_batchInfo;
    unsigned long long _fetchLimit;
    NSMutableArray *_searchResultIDs;
    NSMutableArray *_cachedResults;
    BOOL _cancelSearch;
    BOOL _backgroundIsFinished;
    BOOL _sortOnMainThread;
    BOOL _hasReturnedResults;
}

- (void).cxx_destruct;
- (id)_performNextFetch;
- (void)_initBatchInfo;
- (void)_configureFetchesForQuery:(id)arg1 andSortDescriptor:(id)arg2;
- (void)performFetch;
- (id)nextResultsInTime:(double)arg1;
- (id)remainingResults;
- (BOOL)hasMoreResults;
- (id)_convertNextIDsToObjectsInTime:(double)arg1;
- (void)cancel;
- (id)initWithQuery:(id)arg1 forDocSet:(id)arg2 withSortDescriptor:(id)arg3;

@end

@interface DocSetHTMLExtractor : NSObject
{
}

+ (id)attributesFromString:(id)arg1;
+ (unsigned long long)_encodingForContentType:(id)arg1;
+ (unsigned long long)encodingForHTMLData:(id)arg1;
+ (id)extractTextFromXMLElement:(id)arg1 returningTitle:(id *)arg2;
+ (id)extractTextFromHTMLString:(id)arg1 returningTitle:(id *)arg2;
+ (id)extractTextFromHTMLFile:(id)arg1 returningTitle:(id *)arg2;

@end

@interface DocSetIndexDocument : NSObject
{
    void *_searchDocument;
}

+ (id)searchDocumentWithScheme:(id)arg1 parent:(id)arg2 name:(id)arg3;
+ (id)searchDocumentWithURL:(id)arg1;
- (void *)documentRef;
- (id)parent;
- (id)name;
- (id)schemeName;
- (id)URL;
- (void)dealloc;
- (id)initWithScheme:(id)arg1 parent:(id)arg2 name:(id)arg3;
- (id)initWithURL:(id)arg1;
- (id)initWithSKDocumentRef:(void *)arg1;

@end

@interface DocSetIndexDocumentIterator : NSObject
{
    struct __SKIndexDocumentIterator *_indexDocumentIterator;
}

- (id)nextDocument;
- (void)dealloc;
- (id)initWithIndex:(id)arg1 parentDocument:(id)arg2;

@end

@interface DocSetIndexSearch : NSObject
{
    struct __SKSearch *_search;
    BOOL _moreToSearch;
}

- (void)cancel;
- (BOOL)isFinished;
- (unsigned long long)findMaximumMatches:(unsigned long long)arg1 inMaximumTime:(double)arg2 returningIDs:(long long *)arg3 andScores:(float *)arg4;
- (struct __SKSearch *)searchRef;
- (void)dealloc;
- (id)initWithIndex:(id)arg1 query:(id)arg2 options:(unsigned int)arg3;

@end

@interface DocSetXMLConverter : NSObject
{
    NSXMLDocument *_docSetInfo;
    NSManagedObjectContext *_moc;
    int _modelVersion;
    id *_error;
    NSMutableDictionary *_nodesByID;
    NSMutableSet *_nodesWithoutIDs;
    NSMutableSet *_nodesWithoutDocumentTypes;
}

+ (BOOL)updateDocSetInfo:(id)arg1 error:(id *)arg2;
+ (BOOL)convertXML:(id)arg1 toContext:(id)arg2 forModelVersion:(int)arg3 withError:(id *)arg4;
- (void).cxx_destruct;
- (BOOL)_updateContext;
- (BOOL)_setUpReleaseNotes;
- (void)_resetTableForEntityNamed:(id)arg1;
- (BOOL)_setUpNodes;
- (void)_addRelatedNodes:(id)arg1 toNode:(id)arg2 withCache:(id)arg3;
- (void)_addSubnodes:(id)arg1 toNode:(id)arg2 withCache:(id)arg3;
- (id)_nodeForXMLNode:(id)arg1 withCache:(id)arg2;
- (void)_setUpNodes:(id)arg1 withCache:(id)arg2;
- (BOOL)_setUpDocSet;
- (void)_updatePrimaryParent;
- (void)_assignDocumentTypesToNodes;
- (void)_assignIDsToNodes;
- (id)_nodeForID:(int)arg1;
- (void)_addNode:(id)arg1 withID:(int)arg2;
- (void)_addNodeWithoutDocumentType:(id)arg1;
- (void)_addNodeWithoutID:(id)arg1;
- (id)initWithXML:(id)arg1 withContext:(id)arg2 forModelVersion:(int)arg3 withError:(id *)arg4;

@end

@interface NSString (DocSetPrivateAddition)
- (id)_dsa_stringAsPathComponent;
@end

@interface NSURL (DocSetPrivateAddition)
- (BOOL)_dsa_isAppleURL;
@end

@interface NSXMLElement (DocSetPrivateAddition)
- (id)_dr_firstChildNamed:(id)arg1;
@end

